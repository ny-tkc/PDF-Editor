<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Master Studio</title>
    <meta name="description" content="高度なPDF編集ツール。結合、ページ削除、回転、注釈（テキスト、赤枠、矢印）の追加が可能。日本語UI対応。" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
              }
            }
          }
        }
      }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF Libraries -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>

    <style>
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f5f9; }
      ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-100 text-slate-800">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- ICONS ---
      const createIcon = (path) => (props) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={props.size || 24} 
          height={props.size || 24} 
          viewBox="0 0 24 24" 
          fill={props.fill || "none"} 
          stroke="currentColor" 
          strokeWidth={props.strokeWidth || 2} 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={props.className}
          {...props}
        >
          {path}
        </svg>
      );

      const Icons = {
        X: createIcon(<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>),
        Square: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        FilledSquare: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        Circle: createIcon(<circle cx="12" cy="12" r="10"></circle>),
        ArrowRight: createIcon(<><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></>),
        Type: createIcon(<><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></>),
        Move: createIcon(<><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></>),
        Check: createIcon(<polyline points="20 6 9 17 4 12"></polyline>),
        Highlighter: createIcon(<><path d="m9 11-6 6v3h9l2-2"></path><path d="m22 7-8.1 8.1"></path><path d="M16 3 2.6 16.4"></path></>),
        ImageIcon: createIcon(<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></>),
        ZoomIn: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        ZoomOut: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        Bold: createIcon(<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>),
        Upload: createIcon(<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></>),
        FileDown: createIcon(<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18v-6"></path><path d="m9 15 3 3 3-3"></path></>),
        Trash2: createIcon(<><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>),
        RotateCw: createIcon(<path d="M23 4v6h-6 M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>),
        Edit3: createIcon(<path d="M12 20h9 M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>),
        Copy: createIcon(<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></>),
        Plus: createIcon(<><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>),
        ChevronDown: createIcon(<polyline points="6 9 12 15 18 9"></polyline>),
        ArrowUpDown: createIcon(<><path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/></>),
        ArrowLeftRight: createIcon(<><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></>), 
        RefreshCcw: createIcon(<><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></>),
        Shapes: createIcon(<><path d="M3 3h18v18H3zM12 8l4 8H8z"/></>),
        Hash: createIcon(<><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></>),
        MessageSquare: createIcon(<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>),
        FolderPlus: createIcon(<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>),
    };
    
      const { 
        X, Square, FilledSquare, Circle, ArrowRight, Type, Move, Check, Highlighter, 
        ImageIcon, ZoomIn, ZoomOut, Bold, 
        Upload, FileDown, Trash2, RotateCw, Edit3, Copy, Plus, 
        ArrowUpDown, ArrowLeftRight, RefreshCcw, Shapes,
        Hash, MessageSquare, FolderPlus
      } = Icons;

      const generateId = () => {
        if (typeof crypto !== 'undefined' && crypto.randomUUID && window.isSecureContext) {
          return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      };

      // --- UTILS ---
      const getBubblePath = (x, y, w, h, tail, type) => {
        const tx = x + tail.x;
        const ty = y + tail.y;
        
        let path = new Path2D();
        
        if (type === 'calloutCircle') {
           const cx = x + w/2;
           const cy = y + h/2;
           const rx = Math.abs(w)/2;
           const ry = Math.abs(h)/2;
           path.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
           path.moveTo(cx + rx * 0.5, cy + ry * 0.8);
           path.lineTo(tx, ty);
           path.lineTo(cx - rx * 0.2, cy + ry * 0.8);
        } else {
           const r = 10;
           const bx = x; const by = y; const bw = w; const bh = h;
           path.moveTo(bx + r, by);
           path.lineTo(bx + bw - r, by);
           path.quadraticCurveTo(bx + bw, by, bx + bw, by + r);
           path.lineTo(bx + bw, by + bh - r);
           path.quadraticCurveTo(bx + bw, by + bh, bx + bw - r, by + bh);
           path.lineTo(bx + bw * 0.7, by + bh);
           path.lineTo(tx, ty);
           path.lineTo(bx + bw * 0.4, by + bh);
           path.lineTo(bx + r, by + bh);
           path.quadraticCurveTo(bx, by + bh, bx, by + bh - r);
           path.lineTo(bx, by + r);
           path.quadraticCurveTo(bx, by, bx + r, by);
        }
        path.closePath();
        return path;
      };

      const loadPDF = async (file) => {
        let arrayBuffer = await file.arrayBuffer();
        let fileName = file.name;

        const isImage = file.type.startsWith('image/') || /\.(jpg|jpeg|png|webp)$/i.test(file.name);

        if (isImage && file.type !== 'application/pdf') {
          try {
            const pdfDoc = await PDFLib.PDFDocument.create();
            let image;
            
            if (file.type === 'image/jpeg' || file.type === 'image/jpg' || fileName.toLowerCase().endsWith('.jpg') || fileName.toLowerCase().endsWith('.jpeg')) {
              image = await pdfDoc.embedJpg(arrayBuffer);
            } else {
              try {
                 image = await pdfDoc.embedPng(arrayBuffer);
              } catch (e) {
                 image = await pdfDoc.embedJpg(arrayBuffer);
              }
            }

            const page = pdfDoc.addPage([image.width, image.height]);
            page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });

            const pdfBytes = await pdfDoc.save();
            arrayBuffer = pdfBytes.buffer;
            fileName = fileName + ".pdf"; 
          } catch (e) {
            console.error("Image to PDF conversion failed", e);
            throw new Error("Unsupported image format.");
          }
        }

        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer.slice(0) });
        const pdf = await loadingTask.promise;
        
        const sourceId = generateId();
        const pages = [];

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          // Scale 2.0 for clearer thumbnails
          const viewport = page.getViewport({ scale: 2.0 }); 
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({ canvasContext: context, viewport: viewport }).promise;

          pages.push({
            id: generateId(),
            sourcePdfId: sourceId,
            pageIndex: i,
            rotation: 0,
            thumbnailUrl: canvas.toDataURL(),
            originalWidth: viewport.width, // Store the higher res dimension
            originalHeight: viewport.height,
            annotations: []
          });
        }

        return {
          source: { id: sourceId, name: fileName, data: arrayBuffer },
          pages
        };
      };

      const generateFinalPDF = async (pages, sources) => {
        const mergedPdf = await PDFLib.PDFDocument.create();

        for (const pageData of pages) {
          const source = sources.get(pageData.sourcePdfId);
          if (!source) continue;

          const sourcePdfDoc = await PDFLib.PDFDocument.load(source.data);
          const [copiedPage] = await mergedPdf.copyPages(sourcePdfDoc, [pageData.pageIndex]);
          
          const currentRotation = copiedPage.getRotation().angle;
          copiedPage.setRotation(PDFLib.degrees(currentRotation + pageData.rotation));

          if (pageData.annotations.length > 0) {
            const canvas = document.createElement('canvas');
            const width = pageData.originalWidth;
            const height = pageData.originalHeight;
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (ctx) {
              ctx.textBaseline = 'top'; 

              for (const ann of pageData.annotations) {
                 ctx.globalAlpha = 1.0; 
                 
                 let boxX = ann.x || 0;
                 let boxY = ann.y || 0;
                 let boxW = ann.width || 0;
                 let boxH = ann.height || 0;

                 if (ann.type !== 'arrow') {
                     if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
                     if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                 }

                 if (ann.type === 'highlight') {
                     ctx.fillStyle = ann.color;
                     ctx.globalAlpha = 0.4;
                     ctx.fillRect(boxX, boxY, boxW, boxH);
                     ctx.globalAlpha = 1.0; 
                 } else if (ann.type === 'rect') {
                   ctx.strokeStyle = ann.color;
                   ctx.lineWidth = 4;
                   ctx.strokeRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'filledRect') {
                   ctx.fillStyle = ann.color;
                   ctx.fillRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'circle') {
                   ctx.strokeStyle = ann.color;
                   ctx.lineWidth = 4;
                   ctx.beginPath();
                   ctx.ellipse(boxX + boxW/2, boxY + boxH/2, Math.abs(boxW)/2, Math.abs(boxH)/2, 0, 0, 2 * Math.PI);
                   ctx.stroke();
                 } else if (ann.type === 'cross') {
                   ctx.strokeStyle = ann.color;
                   ctx.lineWidth = 4;
                   ctx.beginPath();
                   ctx.moveTo(boxX, boxY);
                   ctx.lineTo(boxX + boxW, boxY + boxH);
                   ctx.moveTo(boxX + boxW, boxY);
                   ctx.lineTo(boxX, boxY + boxH);
                   ctx.stroke();
                 } else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 32;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 } else if ((ann.type === 'callout' || ann.type === 'calloutCircle') && ann.text) {
                   ctx.fillStyle = 'white';
                   ctx.strokeStyle = ann.color;
                   ctx.lineWidth = 3;
                   
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   const tx = boxX + tail.x;
                   const ty = boxY + tail.y;

                   ctx.beginPath();
                   if (ann.type === 'calloutCircle') {
                       ctx.ellipse(boxX + boxW/2, boxY + boxH/2, boxW/2, boxH/2, 0, 0, 2 * Math.PI);
                       ctx.moveTo(boxX + boxW/2 + 10, boxY + boxH * 0.85); 
                       ctx.lineTo(tx, ty);
                       ctx.lineTo(boxX + boxW/2 - 10, boxY + boxH * 0.85);
                   } else {
                       const r = 10;
                       ctx.moveTo(boxX + r, boxY);
                       ctx.lineTo(boxX + boxW - r, boxY);
                       ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + r);
                       ctx.lineTo(boxX + boxW, boxY + boxH - r);
                       ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - r, boxY + boxH);
                       ctx.lineTo(boxX + boxW * 0.6, boxY + boxH);
                       ctx.lineTo(tx, ty);
                       ctx.lineTo(boxX + boxW * 0.4, boxY + boxH);
                       ctx.lineTo(boxX + r, boxY + boxH);
                       ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - r);
                       ctx.lineTo(boxX, boxY + r);
                       ctx.quadraticCurveTo(boxX, boxY, boxX + r, boxY);
                   }
                   ctx.closePath();
                   ctx.fill();
                   ctx.stroke();
                   
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 24;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   const metrics = ctx.measureText(ann.text);
                   const textX = boxX + (boxW - metrics.width)/2;
                   const textY = boxY + (boxH - fSize)/2;
                   ctx.fillText(ann.text, textX, textY);
                   
                 } else if (ann.type === 'arrow') {
                   ctx.strokeStyle = ann.color;
                   ctx.fillStyle = ann.color;
                   ctx.lineWidth = 5;
                   
                   const startX = ann.x;
                   const startY = ann.y;
                   const endX = ann.x + ann.width;
                   const endY = ann.y + ann.height;
                   
                   const headLen = 20; 
                   const angle = Math.atan2(endY - startY, endX - startX);
                   
                   ctx.beginPath();
                   ctx.moveTo(startX, startY);
                   ctx.lineTo(endX, endY);
                   ctx.stroke();
                   
                   ctx.beginPath();
                   ctx.moveTo(endX, endY);
                   ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                   ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                   ctx.closePath();
                   ctx.fill();
                 } else if (ann.type === 'image' && ann.imageData) {
                     await new Promise((resolve) => {
                         const img = new Image();
                         img.onload = () => {
                             ctx.drawImage(img, boxX, boxY, boxW, boxH);
                             resolve(null);
                         };
                         img.src = ann.imageData; 
                     });
                 }
              }

              const pngImageBytes = await fetch(canvas.toDataURL('image/png')).then(res => res.arrayBuffer());
              const pngImage = await mergedPdf.embedPng(pngImageBytes);
              
              copiedPage.drawImage(pngImage, {
                x: 0,
                y: 0,
                width: copiedPage.getWidth(),
                height: copiedPage.getHeight(),
              });
            }
          }

          mergedPdf.addPage(copiedPage);
        }

        return await mergedPdf.save();
      };

      const renderHighResPage = async (pageData, source) => {
          const loadingTask = pdfjsLib.getDocument({ data: source.data.slice(0) });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(pageData.pageIndex + 1);
          const viewport = page.getViewport({ scale: 3.0, rotation: pageData.rotation });
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({ canvasContext: context, viewport: viewport }).promise;
          return canvas.toDataURL();
      };

      // --- COMPONENTS ---

      const AnnotationEditor = ({ page, imageSrc, onClose, onSave }) => {
        const [annotations, setAnnotations] = useState(page.annotations || []);
        const [tool, setTool] = useState('select');
        const [subTool, setSubTool] = useState(null); 
        const [showShapeMenu, setShowShapeMenu] = useState(false);
        const [showTextMenu, setShowTextMenu] = useState(false);
        
        // Settings
        const [color, setColor] = useState('#ef4444');
        const [fontSize, setFontSize] = useState(32);
        const [fontFamily, setFontFamily] = useState('Meiryo UI');
        const [isBold, setIsBold] = useState(false);
        const [zoom, setZoom] = useState(0.8);
        
        // Interaction
        const [isDrawing, setIsDrawing] = useState(false);
        const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 }); 
        const [currentAnnotation, setCurrentAnnotation] = useState(null); 
        
        // Selection
        const [selectedId, setSelectedId] = useState(null);
        const [interactionMode, setInteractionMode] = useState('none');
        const [resizeHandle, setResizeHandle] = useState(null);
        const [interactionStartPos, setInteractionStartPos] = useState({ x: 0, y: 0 });
        const [initialAnnState, setInitialAnnState] = useState(null);
        
        const imgRef = useRef(null);
        const containerRef = useRef(null);
        const fileInputRef = useRef(null);

        const fitWidth = () => {
          if (containerRef.current) {
            const containerW = containerRef.current.clientWidth - 64; 
            setZoom(containerW / page.originalWidth);
          }
        };

        const fitHeight = () => {
          if (containerRef.current) {
             const containerH = containerRef.current.clientHeight - 64; 
             setZoom(containerH / page.originalHeight);
          }
        };
        
        useEffect(() => {
           fitHeight();
        }, []);

        useEffect(() => {
          if (selectedId) {
              setAnnotations(prev => prev.map(ann => {
                  if (ann.id === selectedId) {
                      const updates = {};
                      if (['text','callout','calloutCircle'].includes(ann.type)) {
                          updates.fontSize = fontSize;
                          updates.fontWeight = isBold ? 'bold' : 'normal';
                          updates.fontFamily = fontFamily;
                      }
                      if (ann.type !== 'image') {
                        updates.color = color;
                      }
                      return { ...ann, ...updates };
                  }
                  return ann;
              }));
          }
        }, [fontSize, isBold, fontFamily, color, selectedId]);

        useEffect(() => {
            const handleKeyDown = (e) => {
                if (!selectedId) return;
                const step = e.shiftKey ? 10 : 2;
                let dx = 0; let dy = 0;
                switch(e.key) {
                    case 'ArrowUp': dy = -step; break;
                    case 'ArrowDown': dy = step; break;
                    case 'ArrowLeft': dx = -step; break;
                    case 'ArrowRight': dx = step; break;
                    case 'Delete': 
                    case 'Backspace':
                        deleteAnnotation(selectedId);
                        return;
                    default: return;
                }
                if (dx !== 0 || dy !== 0) {
                    e.preventDefault();
                    setAnnotations(prev => prev.map(ann => {
                        if (ann.id === selectedId) {
                            return { ...ann, x: ann.x + dx, y: ann.y + dy };
                        }
                        return ann;
                    }));
                }
            };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedId]);

        const getPointerPos = (e) => {
          if (!imgRef.current) return { x: 0, y: 0 };
          const rect = imgRef.current.getBoundingClientRect();
          const relX = e.clientX - rect.left;
          const relY = e.clientY - rect.top;
          const scaleX = page.originalWidth / rect.width;
          const scaleY = page.originalHeight / rect.height;
          return { x: relX * scaleX, y: relY * scaleY };
        };
        
        const selectTool = (t) => {
           setSelectedId(null);
           setTool(t);
           const defaults = {
             rect: '#ef4444',
             filledRect: '#000000',
             circle: '#ef4444',
             cross: '#ef4444',
             arrow: '#ef4444',
             text: '#000000',
             callout: '#000000',
             calloutCircle: '#000000',
             highlight: '#ffff00'
           };
           if (defaults[t]) setColor(defaults[t]);
        };

        const handleMouseDown = (e) => {
          if (interactionMode !== 'none') return;
          if (tool === 'select') { setSelectedId(null); return; }
          
          e.preventDefault();
          const { x, y } = getPointerPos(e);
          setDragStartPos({ x, y });
          setIsDrawing(true);

          if (['text','callout','calloutCircle'].includes(tool)) {
             const text = prompt("テキストを入力してください:", "");
             if (text && text.trim() !== "") {
               const newAnn = {
                 id: generateId(),
                 type: tool,
                 x, y,
                 width: tool !== 'text' ? 200 : undefined,
                 height: tool !== 'text' ? 100 : undefined,
                 text, color, fontSize,
                 fontWeight: isBold ? 'bold' : 'normal',
                 fontFamily: fontFamily,
                 tailTip: tool !== 'text' ? { x: 100, y: 150 } : undefined 
               };
               setAnnotations([...annotations, newAnn]);
               setSelectedId(newAnn.id); 
               setTool('select');
             }
             setIsDrawing(false);
          } else if (tool === 'image') {
              fileInputRef.current?.click();
              setIsDrawing(false);
          } else {
            setCurrentAnnotation({ type: tool, x, y, width: 0, height: 0, color });
          }
        };

        const handleMouseMove = (e) => {
          const { x, y } = getPointerPos(e);

          if (interactionMode === 'moving' && selectedId && initialAnnState) {
              const dx = x - interactionStartPos.x;
              const dy = y - interactionStartPos.y;
              setAnnotations(prev => prev.map(ann => {
                  if (ann.id === selectedId) {
                      return { ...ann, x: initialAnnState.x + dx, y: initialAnnState.y + dy };
                  }
                  return ann;
              }));
              return;
          }

          if (interactionMode === 'resizing' && selectedId && initialAnnState && resizeHandle) {
              const dx = x - interactionStartPos.x;
              const dy = y - interactionStartPos.y;

              setAnnotations(prev => prev.map(ann => {
                  if (ann.id !== selectedId) return ann;
                  
                  if (ann.type === 'text') {
                       const scaleFactor = 1 + (dy / 100); 
                       const newSize = Math.max(10, initialAnnState.fontSize * scaleFactor);
                       return { ...ann, fontSize: newSize };
                  }

                  let newX = initialAnnState.x;
                  let newY = initialAnnState.y;
                  let newW = initialAnnState.width || 0;
                  let newH = initialAnnState.height || 0;
                  
                  if (resizeHandle.includes('e')) newW += dx;
                  if (resizeHandle.includes('w')) { newX += dx; newW -= dx; }
                  if (resizeHandle.includes('s')) newH += dy;
                  if (resizeHandle.includes('n')) { newY += dy; newH -= dy; }

                  return { ...ann, x: newX, y: newY, width: newW, height: newH };
              }));
              return;
          }
          
          if (interactionMode === 'tail' && selectedId && initialAnnState) {
             const dx = x - interactionStartPos.x;
             const dy = y - interactionStartPos.y;
             setAnnotations(prev => prev.map(ann => {
                 if (ann.id !== selectedId) return ann;
                 const baseTail = initialAnnState.tailTip || {x: initialAnnState.width/2, y: initialAnnState.height + 50};
                 return {
                     ...ann,
                     tailTip: { x: baseTail.x + dx, y: baseTail.y + dy }
                 };
             }));
             return;
          }

          if (!isDrawing || !currentAnnotation) return;
          const dx = x - dragStartPos.x;
          const dy = y - dragStartPos.y;
          setCurrentAnnotation(prev => ({ ...prev, width: dx, height: dy }));
        };

        const handleMouseUp = () => {
          setInteractionMode('none');
          setResizeHandle(null);
          setInitialAnnState(null);

          if (!isDrawing) return;
          setIsDrawing(false);
          
          if (currentAnnotation && (Math.abs(currentAnnotation.width) > 5 || Math.abs(currentAnnotation.height) > 5)) {
             const newAnn = {
               id: generateId(),
               type: currentAnnotation.type,
               x: dragStartPos.x, 
               y: dragStartPos.y, 
               width: currentAnnotation.width,
               height: currentAnnotation.height,
               color: currentAnnotation.color,
             };
             setAnnotations([...annotations, newAnn]);
          }
          setCurrentAnnotation(null);
        };

        const handleClipboardCopy = async () => {
             const canvas = document.createElement('canvas');
             const img = new Image();
             img.onload = async () => {
                 canvas.width = page.originalWidth;
                 canvas.height = page.originalHeight;
                 const ctx = canvas.getContext('2d');
                 ctx.drawImage(img, 0, 0, page.originalWidth, page.originalHeight);
                 
                 for (const ann of annotations) {
                     let x = ann.x || 0; let y = ann.y || 0; let w = ann.width || 0; let h = ann.height || 0;
                     if (ann.type !== 'arrow') {
                         if (w < 0) { x += w; w = Math.abs(w); }
                         if (h < 0) { y += h; h = Math.abs(h); }
                     }
                     
                     ctx.save();
                     if (ann.type === 'highlight') {
                         ctx.fillStyle = ann.color; ctx.globalAlpha = 0.4; ctx.fillRect(x,y,w,h);
                     } else if (ann.type === 'rect') {
                         ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.strokeRect(x,y,w,h);
                     } else if (ann.type === 'filledRect') {
                         ctx.fillStyle = ann.color; ctx.fillRect(x,y,w,h);
                     } else if (ann.type === 'text' && ann.text) {
                         ctx.fillStyle = ann.color; ctx.font = `${ann.fontWeight||'normal'} ${ann.fontSize||32}px ${ann.fontFamily||'sans-serif'}`; ctx.textBaseline='top'; ctx.fillText(ann.text, x, y);
                     } else if ((ann.type === 'callout' || ann.type === 'calloutCircle') && ann.text) {
                         ctx.fillStyle = 'white'; ctx.strokeStyle = ann.color; ctx.lineWidth = 3;
                         const tail = ann.tailTip || { x: w/2, y: h + 50 };
                         const tx = x + tail.x; const ty = y + tail.y;
                         ctx.beginPath();
                         if (ann.type === 'calloutCircle') {
                            ctx.ellipse(x+w/2, y+h/2, w/2, h/2, 0, 0, 2 * Math.PI);
                            ctx.moveTo(x + w/2 + 10, y + h * 0.85); ctx.lineTo(tx, ty); ctx.lineTo(x + w/2 - 10, y + h * 0.85);
                         } else {
                            const r = 10;
                            ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r); ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                            ctx.lineTo(x + w * 0.6, y + h); ctx.lineTo(tx, ty); ctx.lineTo(x + w * 0.4, y + h);
                            ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                         }
                         ctx.closePath(); ctx.fill(); ctx.stroke();
                         ctx.fillStyle = ann.color;
                         ctx.font = `${ann.fontWeight||'normal'} ${ann.fontSize||24}px ${ann.fontFamily||'sans-serif'}`;
                         const metrics = ctx.measureText(ann.text);
                         ctx.fillText(ann.text, x + (w-metrics.width)/2, y + (h-(ann.fontSize||24))/2);
                     } else if (ann.type === 'arrow') {
                          const startX = ann.x; const startY = ann.y; const endX = ann.x + ann.width; const endY = ann.y + ann.height;
                          const headLen = 20; const angle = Math.atan2(endY - startY, endX - startX);
                          ctx.strokeStyle = ann.color; ctx.fillStyle = ann.color; ctx.lineWidth = 5;
                          ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
                          ctx.beginPath(); ctx.moveTo(endX, endY);
                          ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                          ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                          ctx.closePath(); ctx.fill();
                     } else if (ann.type === 'circle') {
                         ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.ellipse(x+w/2, y+h/2, w/2, h/2, 0, 0, 2*Math.PI); ctx.stroke();
                     } else if (ann.type === 'cross') {
                         ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+w,y+h); ctx.moveTo(x+w,y); ctx.lineTo(x,y+h); ctx.stroke();
                     }
                     ctx.restore();
                 }

                 canvas.toBlob(blob => {
                     navigator.clipboard.write([new ClipboardItem({[blob.type]: blob})])
                       .then(() => alert("画像をコピーしました"))
                       .catch(e => alert("コピーに失敗しました"));
                 });
             };
             img.src = imageSrc;
        };

        const handleResizeStart = (e, handle, id) => {
            e.stopPropagation(); e.preventDefault();
            const ann = annotations.find(a => a.id === id);
            if (!ann) return;
            setSelectedId(id); setInteractionMode('resizing'); setResizeHandle(handle); setInteractionStartPos(getPointerPos(e)); setInitialAnnState({ ...ann });
        };
        
        const handleTailDragStart = (e, id) => {
            e.stopPropagation(); e.preventDefault();
            const ann = annotations.find(a => a.id === id);
            if (!ann) return;
            setSelectedId(id); setInteractionMode('tail'); setInteractionStartPos(getPointerPos(e)); setInitialAnnState({ ...ann });
        };

        const deleteAnnotation = (id) => {
          setAnnotations(annotations.filter(a => a.id !== id));
          if (selectedId === id) setSelectedId(null);
        };

        const renderAnnotation = (ann, isPreview = false) => {
           const isSelected = !isPreview && ann.id === selectedId;

           let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
           if (ann.type !== 'arrow') {
               if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
               if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
           } else {
               const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height);
               const maxX = Math.max(ann.x, ann.x + ann.width); const maxY = Math.max(ann.y, ann.y + ann.height);
               boxX = minX; boxY = minY; boxW = maxX - minX; boxH = maxY - minY;
           }

           if (ann.type === 'text') { boxW = undefined; boxH = undefined; }

           const style = {
             position: 'absolute',
             left: `${(boxX / page.originalWidth) * 100}%`,
             top: `${(boxY / page.originalHeight) * 100}%`,
             width: boxW !== undefined ? `${(boxW / page.originalWidth) * 100}%` : 'auto',
             height: boxH !== undefined ? `${(boxH / page.originalHeight) * 100}%` : 'auto',
             pointerEvents: tool === 'select' && !isPreview ? 'auto' : 'none',
             cursor: tool === 'select' ? 'move' : 'crosshair',
             zIndex: isPreview ? 20 : (isSelected ? 30 : 10),
             outline: isSelected ? '2px dashed #0ea5e9' : 'none',
           };

           const renderHandles = () => {
               if (!isSelected || !ann.id) return null;
               const hStyle = "absolute w-3 h-3 bg-white border border-brand-500 rounded-full z-50 pointer-events-auto";
               return (
                   <>
                      <div className={`${hStyle} -top-1.5 -left-1.5 cursor-nw-resize`} onMouseDown={(e) => handleResizeStart(e, 'nw', ann.id)} />
                      <div className={`${hStyle} -top-1.5 -right-1.5 cursor-ne-resize`} onMouseDown={(e) => handleResizeStart(e, 'ne', ann.id)} />
                      <div className={`${hStyle} -bottom-1.5 -left-1.5 cursor-sw-resize`} onMouseDown={(e) => handleResizeStart(e, 'sw', ann.id)} />
                      <div className={`${hStyle} -bottom-1.5 -right-1.5 cursor-se-resize`} onMouseDown={(e) => handleResizeStart(e, 'se', ann.id)} />
                      {(ann.type === 'callout' || ann.type === 'calloutCircle') && ann.tailTip && (
                          <div 
                              className="absolute w-4 h-4 bg-yellow-400 border border-black rounded-full z-50 cursor-crosshair shadow-sm pointer-events-auto"
                              style={{ 
                                  left: `${(ann.tailTip.x / boxW) * 100}%`,
                                  top: `${(ann.tailTip.y / boxH) * 100}%`,
                                  transform: 'translate(-50%, -50%)'
                              }}
                              onMouseDown={(e) => handleTailDragStart(e, ann.id)}
                          />
                      )}
                   </>
               );
           }

           const renderContent = () => {
               if (ann.type === 'arrow') {
                   const globalStartX = ann.x; const globalStartY = ann.y;
                   const globalEndX = ann.x + ann.width; const globalEndY = ann.y + ann.height;
                   const minX = Math.min(globalStartX, globalEndX); const minY = Math.min(globalStartY, globalEndY);
                   const x1 = globalStartX - minX; const y1 = globalStartY - minY;
                   const x2 = globalEndX - minX; const y2 = globalEndY - minY;
                   const headLen = 20 * (1/zoom * 0.5 + 0.5);
                   const angle = Math.atan2(y2 - y1, x2 - x1);
                   const ax1 = x2 - headLen * Math.cos(angle - Math.PI / 6);
                   const ay1 = y2 - headLen * Math.sin(angle - Math.PI / 6);
                   const ax2 = x2 - headLen * Math.cos(angle + Math.PI / 6);
                   const ay2 = y2 - headLen * Math.sin(angle + Math.PI / 6);
                   return (
                       <svg width="100%" height="100%" style={{ overflow: 'visible', pointerEvents: 'none' }}>
                           <line x1={x1} y1={y1} x2={x2} y2={y2} stroke="transparent" strokeWidth="20" style={{ pointerEvents: 'stroke' }} />
                           <line x1={x1} y1={y1} x2={x2} y2={y2} stroke={ann.color} strokeWidth="5" />
                           <polygon points={`${x2},${y2} ${ax1},${ay1} ${ax2},${ay2}`} fill={ann.color} />
                       </svg>
                   );
               }
               if (ann.type === 'callout' || ann.type === 'calloutCircle') {
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   return (
                       <div style={{ width: '100%', height: '100%', overflow: 'visible' }}>
                           <svg width="1" height="1" style={{ overflow: 'visible', width: '100%', height: '100%' }}>
                               <path 
                                  d={(() => {
                                      const w = boxW; const h = boxH;
                                      const tx = tail.x; const ty = tail.y;
                                      if (ann.type === 'calloutCircle') {
                                          const rx = w/2; const ry = h/2;
                                          let d = `M ${w} ${h/2} A ${rx} ${ry} 0 1 0 0 ${h/2} A ${rx} ${ry} 0 1 0 ${w} ${h/2} `;
                                          d += `M ${w/2 + 10} ${h*0.85} L ${tx} ${ty} L ${w/2 - 10} ${h*0.85}`;
                                          return d;
                                      } else {
                                          const r = 10;
                                          let d = `M ${r} 0 L ${w-r} 0 Q ${w} 0 ${w} ${r} L ${w} ${h-r} Q ${w} ${h} ${w-r} ${h}`;
                                          d += ` L ${w*0.6} ${h} L ${tx} ${ty} L ${w*0.4} ${h}`;
                                          d += ` L ${r} ${h} Q 0 ${h} 0 ${h-r} L 0 ${r} Q 0 0 ${r} 0`;
                                          return d;
                                      }
                                  })()}
                                  fill="white" stroke={ann.color} strokeWidth="2" vectorEffect="non-scaling-stroke" 
                               />
                           </svg>
                           <div style={{ position:'absolute', inset:0, display:'flex', alignItems:'center', justifyContent:'center', pointerEvents:'none' }}>
                               <span style={{ color: ann.color, fontSize: `${(ann.fontSize || 24) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily }}>{ann.text}</span>
                           </div>
                       </div>
                   )
               }
               if (ann.type === 'text') {
                   return <div style={{ color: ann.color, fontSize: `${(ann.fontSize || 32) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily, whiteSpace: 'nowrap', textShadow: '0 0 3px white', padding:'4px', lineHeight:1 }}>{ann.text}</div>;
               }
               if (ann.type === 'circle') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}`, borderRadius: '50%' }} />;
               if (ann.type === 'cross') return <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"><line x1="0" y1="0" x2="100" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/><line x1="100" y1="0" x2="0" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/></svg>;
               if (ann.type === 'image') return <img src={ann.imageData} className="w-full h-full object-contain" draggable={false} />;
               if (ann.type === 'highlight') return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color, opacity: 0.3 }} />;
               if (ann.type === 'rect') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}` }} />;
               if (ann.type === 'filledRect') return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color }} />;
               return null;
           }

           return (
              <div key={ann.id || 'preview'} style={style} onMouseDown={(e) => ann.id && !isPreview && handleMouseDown(e)}>
                  <div style={{width:'100%', height:'100%'}} onMouseDown={(e) => {
                      if(!isPreview) {
                          e.stopPropagation();
                          setTool('select');
                          setSelectedId(ann.id);
                          setInteractionMode('moving');
                          setInteractionStartPos(getPointerPos(e));
                          setInitialAnnState({...ann});
                          if (ann.type !== 'image') setColor(ann.color);
                      }
                  }}>
                    {renderContent()}
                  </div>
                  {renderHandles()}
              </div>
           );
        };

        const shapeTools = [
            { id: 'rect', icon: <Square size={20} />, label: '枠' },
            { id: 'filledRect', icon: <FilledSquare size={20} fill="currentColor" />, label: '塗りつぶし' },
            { id: 'circle', icon: <Circle size={20} />, label: '円' },
            { id: 'cross', icon: <X size={20} />, label: 'バツ' },
            { id: 'arrow', icon: <ArrowRight size={20} />, label: '矢印' },
        ];
        
        const textTools = [
            { id: 'text', icon: <Type size={20} />, label: 'テキスト' },
            { id: 'callout', icon: <MessageSquare size={20} />, label: '吹き出し(角)' },
            { id: 'calloutCircle', icon: <MessageSquare size={20} className="rounded-full" />, label: '吹き出し(丸)' },
        ];

        return (
          <div className="fixed inset-0 bg-slate-900 z-50 flex flex-col">
            <div className="bg-white p-3 flex justify-between items-center shadow-md z-20">
              <h2 className="text-lg font-bold flex items-center gap-2 text-slate-700">
                  <Move className="text-brand-600" size={20}/> ページ編集
              </h2>
              
              <div className="flex items-center gap-4">
                   <div className={`flex items-center gap-2 border-r border-slate-300 pr-4 transition-opacity ${['text','callout','calloutCircle'].includes(tool) || (selectedId && ['text','callout','calloutCircle'].includes(annotations.find(a=>a.id===selectedId)?.type)) ? 'opacity-100' : 'opacity-30 pointer-events-none'}`}>
                       <Type size={16} className="text-slate-500" />
                       <select value={fontFamily} onChange={(e) => setFontFamily(e.target.value)} className="border border-slate-300 rounded px-1 py-0.5 text-sm w-32">
                           <option value="Meiryo UI">メイリオUI</option>
                           <option value="sans-serif">ゴシック体</option>
                           <option value="serif">明朝体</option>
                       </select>
                       <input type="number" value={fontSize} onChange={(e) => setFontSize(Number(e.target.value))} className="w-16 border border-slate-300 rounded px-1 py-0.5 text-sm" />
                       <button onClick={() => setIsBold(!isBold)} className={`p-1 rounded ${isBold ? 'bg-brand-100 text-brand-600 border border-brand-200' : 'text-slate-500 hover:bg-slate-100'}`}><Bold size={16} /></button>
                   </div>
                   
                   <button onClick={handleClipboardCopy} className="p-2 text-slate-600 hover:bg-slate-100 rounded" title="画像をコピー"><Copy size={20} /></button>
                   <div className="flex items-center gap-1 bg-slate-100 rounded-lg p-1 px-3 text-sm text-slate-600 font-mono">{Math.round(zoom * 100)}%</div>
                   <div className="flex gap-2 ml-4">
                      <button onClick={onClose} className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded text-sm font-medium">キャンセル</button>
                      <button onClick={() => onSave(annotations)} className="px-6 py-2 bg-brand-600 text-white rounded shadow-sm hover:bg-brand-700 font-bold flex items-center gap-2 text-sm"><Check size={18} /> 完了</button>
                  </div>
              </div>
            </div>

            <div className="flex flex-1 overflow-hidden relative">
              <div className="w-16 bg-slate-800 flex flex-col items-center py-4 gap-3 z-20 shadow-xl overflow-visible shrink-0">
                  <input type="file" ref={fileInputRef} className="hidden" accept="image/*" onChange={(e) => { 
                      if (e.target.files && e.target.files[0]) {
                          const reader = new FileReader();
                          reader.onload = (ev) => {
                             const newAnn = { id: generateId(), type: 'image', x: 50, y: 50, width: 300, height: 300, imageData: ev.target.result };
                             setAnnotations([...annotations, newAnn]);
                             setTool('select');
                          };
                          reader.readAsDataURL(e.target.files[0]);
                      }
                  }} />
                  
                  <ToolButton active={tool === 'select'} onClick={() => selectTool('select')} icon={<Move size={20} />} label="移動/選択" />
                  <div className="w-10 h-px bg-slate-600 my-1"></div>
                  
                  {/* Text Menu */}
                  <div className="relative group w-full px-2 flex justify-center">
                       <button onClick={() => setShowTextMenu(!showTextMenu)} className={`p-3 rounded-lg flex flex-col items-center gap-1 w-full ${['text','callout','calloutCircle'].includes(tool) ? 'bg-brand-500 text-white' : 'text-slate-400 hover:bg-slate-700'}`}>
                           <Type size={20} /> <span className="text-[10px]">テキスト</span>
                       </button>
                       {showTextMenu && (
                           <div className="absolute left-full top-0 ml-4 bg-slate-700 rounded-lg shadow-xl p-2 flex flex-col gap-2 w-36 z-50">
                               {textTools.map(t => (
                                   <button key={t.id} onClick={() => { selectTool(t.id); setShowTextMenu(false); }} className="flex items-center gap-3 text-slate-200 hover:bg-slate-600 p-2 rounded text-sm">{t.icon} {t.label}</button>
                               ))}
                           </div>
                       )}
                  </div>
                  
                  <ToolButton active={tool === 'highlight'} onClick={() => selectTool('highlight')} icon={<Highlighter size={20} />} label="蛍光ペン" />
                  
                  {/* Shapes Menu */}
                  <div className="relative group w-full px-2 flex justify-center">
                       <button onClick={() => setShowShapeMenu(!showShapeMenu)} className={`p-3 rounded-lg flex flex-col items-center gap-1 w-full ${['rect','filledRect','circle','cross','arrow'].includes(tool) ? 'bg-brand-500 text-white' : 'text-slate-400 hover:bg-slate-700'}`}>
                           <Shapes size={20} /> <span className="text-[10px]">図形</span>
                       </button>
                       {showShapeMenu && (
                           <div className="absolute left-full top-0 ml-4 bg-slate-700 rounded-lg shadow-xl p-2 flex flex-col gap-2 w-32 z-50">
                               {shapeTools.map(t => (
                                   <button key={t.id} onClick={() => { selectTool(t.id); setShowShapeMenu(false); }} className="flex items-center gap-3 text-slate-200 hover:bg-slate-600 p-2 rounded text-sm">{t.icon} {t.label}</button>
                               ))}
                           </div>
                       )}
                  </div>

                  <ToolButton active={tool === 'image'} onClick={() => selectTool('image')} icon={<ImageIcon size={20} />} label="画像" />
                  
                  <div className="w-10 h-px bg-slate-600 my-1"></div>
                  <div className="flex flex-col gap-2 mt-2">
                      {['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#000000', '#ffffff'].map(c => (
                          <button key={c} onClick={() => { setColor(c); if(selectedId) { setAnnotations(prev=>prev.map(a=>a.id===selectedId && a.type!=='image'?{...a,color:c}:a)) } }} className={`w-6 h-6 rounded-full border-2 ${color === c ? 'border-white scale-110' : 'border-transparent'}`} style={{ backgroundColor: c }} />
                      ))}
                  </div>
              </div>

              <div className="flex-1 bg-slate-500 overflow-auto relative flex items-center justify-center p-8" ref={containerRef}>
                   <div className="relative bg-white shadow-2xl origin-center" style={{ width: page.originalWidth * zoom, height: page.originalHeight * zoom }}>
                        <img ref={imgRef} src={imageSrc} className="absolute inset-0 w-full h-full object-contain pointer-events-none select-none" draggable={false} />
                        <div className="absolute inset-0 z-10" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} style={{ cursor: tool === 'select' ? 'default' : 'crosshair' }}>
                            {annotations.map(ann => renderAnnotation(ann))}
                            {currentAnnotation && renderAnnotation(currentAnnotation, true)}
                        </div>
                   </div>

                   <div className="fixed right-6 bottom-6 flex flex-col bg-white rounded-lg shadow-lg border border-slate-200 overflow-hidden z-40">
                       <button onClick={() => setZoom(z => z + 0.1)} className="p-3 hover:bg-slate-50 text-slate-600 border-b border-slate-100" title="拡大"><ZoomIn size={20} /></button>
                       <button onClick={() => setZoom(z => Math.max(0.1, z - 0.1))} className="p-3 hover:bg-slate-50 text-slate-600 border-b border-slate-100" title="縮小"><ZoomOut size={20} /></button>
                       <button onClick={fitHeight} className="p-3 hover:bg-slate-50 text-slate-600 border-b border-slate-100" title="縦幅に合わせる"><ArrowUpDown size={20} /></button>
                       <button onClick={fitWidth} className="p-3 hover:bg-slate-50 text-slate-600 border-b border-slate-100" title="横幅に合わせる"><ArrowLeftRight size={20} className="rotate-90" /></button>
                       <button onClick={fitHeight} className="p-3 hover:bg-slate-50 text-slate-600" title="リセット"><RefreshCcw size={20} /></button>
                   </div>
              </div>
            </div>
          </div>
        );
      };

      const ToolButton = ({ active, onClick, icon, label }) => (
          <button onClick={onClick} className={`p-3 rounded-lg flex flex-col items-center gap-1 w-full ${active ? 'bg-brand-500 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700 hover:text-white'}`} title={label}>
              {icon} <span className="text-[10px] whitespace-nowrap">{label}</span>
          </button>
      );

      function App() {
        const [pages, setPages] = useState([]);
        const [sources, setSources] = useState(new Map());
        const [selectedPageIds, setSelectedPageIds] = useState(new Set());
        const [isProcessing, setIsProcessing] = useState(false);
        const [isDraggingFile, setIsDraggingFile] = useState(false);
        const [editorPage, setEditorPage] = useState(null);
        const [draggedPageIndex, setDraggedPageIndex] = useState(null);
        const [showPageNumModal, setShowPageNumModal] = useState(false);
        const [pageNumMode, setPageNumMode] = useState('none'); 

        const fileInputRef = useRef(null);

        const processFiles = useCallback(async (files, isPaste = false) => {
          if (files.length === 0) return;
          setIsProcessing(true);
          try {
              const newSources = new Map(sources);
              const newPages = [...pages];
              let lastAddedPage = null; let lastAddedSource = null;
              for (const file of files) {
                   try {
                      const { source, pages: extractedPages } = await loadPDF(file);
                      newSources.set(source.id, source);
                      extractedPages.forEach(p => newPages.push(p));
                      if (extractedPages.length > 0) { lastAddedPage = extractedPages[0]; lastAddedSource = source; }
                   } catch (e) { console.error(e); }
              }
              setSources(newSources);
              const updatedPages = applyPageNumbers(newPages, pageNumMode);
              setPages(updatedPages);
              
              if (isPaste && lastAddedPage && lastAddedSource) {
                   const url = await renderHighResPage(lastAddedPage, lastAddedSource);
                   setEditorPage({ page: lastAddedPage, highResUrl: url });
              }
          } catch (e) { alert("エラーが発生しました。"); } finally { setIsProcessing(false); }
        }, [pages, sources, pageNumMode]);

        const applyPageNumbers = (currentPages, mode) => {
            if (mode === 'none') {
                return currentPages.map(p => ({
                    ...p,
                    annotations: p.annotations.filter(a => !a.isPageNumber)
                }));
            }
            return currentPages.map((page, i) => {
                const cleanAnns = page.annotations.filter(a => !a.isPageNumber);
                const fontSize = 24;
                let x = 0; let y = 0;
                if (mode === 'bottom-center') {
                    x = page.originalWidth / 2 - 10; y = page.originalHeight - 50;
                } else {
                    x = page.originalWidth - 80; y = page.originalHeight - 50;
                }
                const numAnn = {
                    id: generateId(),
                    type: 'text',
                    text: `${i + 1}`,
                    x, y,
                    color: '#000000', fontSize, fontWeight: 'normal', fontFamily: 'sans-serif',
                    isPageNumber: true
                };
                return { ...page, annotations: [...cleanAnns, numAnn] };
            });
        };

        const updatePageNumberMode = (mode) => {
            setPageNumMode(mode);
            setPages(prev => applyPageNumbers(prev, mode));
            setShowPageNumModal(false);
        };

        const handlePageDrop = (e, dropIndex) => {
            e.preventDefault(); e.stopPropagation(); 
            if (draggedPageIndex === null || draggedPageIndex === dropIndex) return;
            const newPages = [...pages];
            const item = newPages.splice(draggedPageIndex, 1)[0];
            newPages.splice(dropIndex, 0, item);
            setPages(applyPageNumbers(newPages, pageNumMode));
            setDraggedPageIndex(null);
        };

        const handleFileUpload = (e) => processFiles(e.target.files);

        const handleSavePDF = async () => {
          if (pages.length === 0) return;
          try {
             const pdfBytes = await generateFinalPDF(pages, sources);
             const suggestedName = "edited.pdf";
             
             if (window.showSaveFilePicker) {
                 try {
                     const handle = await window.showSaveFilePicker({
                         suggestedName,
                         types: [{ description: 'PDF File', accept: {'application/pdf': ['.pdf']} }]
                     });
                     const writable = await handle.createWritable();
                     await writable.write(pdfBytes);
                     await writable.close();
                 } catch (e) {
                     // Fallback if cancelled or error
                     if (e.name !== 'AbortError') download(pdfBytes, suggestedName, "application/pdf");
                 }
             } else {
                 const name = prompt("ファイル名を入力してください", suggestedName);
                 if(name) download(pdfBytes, name.endsWith('.pdf') ? name : name + '.pdf', "application/pdf");
             }
          } catch (e) {
            console.error(e);
            alert("保存中にエラーが発生しました。");
          }
        };

        const handleDeletePages = () => {
            const newPages = pages.filter(p => !selectedPageIds.has(p.id));
            setPages(applyPageNumbers(newPages, pageNumMode));
            setSelectedPageIds(new Set());
        };

        const handleReset = () => {
            if (confirm("現在の内容を破棄して新しいプロジェクトを開始しますか？")) {
                setPages([]);
                setSources(new Map());
                setSelectedPageIds(new Set());
                setPageNumMode('none');
            }
        };

        const handleEditPage = async (page) => {
           const source = sources.get(page.sourcePdfId);
           if (!source) return;
           const url = await renderHighResPage(page, source);
           setEditorPage({ page, highResUrl: url });
        };

        const handleSaveAnnotation = (newAnnotations) => {
           if (!editorPage) return;
           setPages(pages.map(p => p.id === editorPage.page.id ? { ...p, annotations: newAnnotations } : p));
           setEditorPage(null);
        };

        useEffect(() => {
           const handlePaste = (e) => {
               if (e.clipboardData && e.clipboardData.files.length > 0) processFiles(e.clipboardData.files, true);
           };
           window.addEventListener('paste', handlePaste);
           return () => window.removeEventListener('paste', handlePaste);
        }, [processFiles]);

        return (
          <div className="min-h-screen flex flex-col" onDragOver={(e) => { 
              e.preventDefault(); 
              // Check if dragging files, not internal elements
              if (e.dataTransfer.types.includes('Files')) setIsDraggingFile(true);
          }} onDragLeave={() => setIsDraggingFile(false)} onDrop={(e) => { 
              e.preventDefault(); 
              if (e.dataTransfer.types.includes('Files')) {
                  setIsDraggingFile(false); 
                  processFiles(e.dataTransfer.files);
              }
          }}>
            
            {/* Header */}
            <div className="bg-white border-b border-slate-200 p-4 px-6 flex justify-between items-center shadow-sm sticky top-0 z-40">
              <div className="flex items-center gap-3">
                 <div className="bg-brand-600 text-white p-2 rounded-lg">
                    <Shapes size={24} />
                 </div>
                 <h1 className="text-xl font-bold text-slate-800 tracking-tight">PDF Master Studio</h1>
              </div>

              <div className="flex gap-3">
                 <button onClick={handleReset} className="p-2 text-slate-500 hover:bg-slate-100 rounded-lg border border-transparent hover:border-slate-200 transition-all" title="新規プロジェクト/リセット"><Trash2 size={20} /></button>
                 <div className="w-px h-8 bg-slate-300 mx-1"></div>
                 
                 <input type="file" multiple accept=".pdf,image/*" className="hidden" ref={fileInputRef} onChange={handleFileUpload} />
                 <button onClick={() => fileInputRef.current?.click()} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg flex items-center gap-2 font-medium transition-colors">
                    <FolderPlus size={18} /> ファイル追加
                 </button>
                 
                 <button onClick={() => setShowPageNumModal(true)} className={`px-4 py-2 ${pageNumMode !== 'none' ? 'bg-brand-100 text-brand-700 border border-brand-200' : 'bg-slate-100 hover:bg-slate-200 text-slate-700'} rounded-lg flex items-center gap-2 font-medium transition-colors`}>
                    <Hash size={18} /> ページ番号
                 </button>

                 <button onClick={handleSavePDF} disabled={pages.length === 0} className="px-6 py-2 bg-brand-600 hover:bg-brand-700 text-white rounded-lg shadow-md flex items-center gap-2 font-bold transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                    <FileDown size={18} /> PDF保存
                 </button>
              </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 p-8 overflow-y-auto">
               {pages.length === 0 ? (
                 <div className="h-full flex flex-col items-center justify-center text-slate-400 border-4 border-dashed border-slate-200 rounded-2xl p-12 bg-slate-50/50">
                    <Upload size={64} className="mb-6 text-brand-200" />
                    <p className="text-xl font-medium text-slate-600">PDFまたは画像をここにドラッグ＆ドロップ</p>
                    <p className="mt-2 text-slate-400">または「ファイル追加」ボタンから選択</p>
                 </div>
               ) : (
                 <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6 pb-20">
                    {pages.map((page, index) => (
                       <div key={page.id} 
                            className={`relative group bg-white rounded-lg shadow-sm border-2 transition-all duration-200 ${selectedPageIds.has(page.id) ? 'border-brand-500 ring-2 ring-brand-100' : 'border-transparent hover:border-brand-200'}`}
                            draggable
                            onDragStart={() => setDraggedPageIndex(index)}
                            onDragOver={(e) => e.preventDefault()}
                            onDrop={(e) => handlePageDrop(e, index)}
                       >
                          {/* Selection Checkbox */}
                          <div className="absolute top-2 left-2 z-10" onClick={(e) => e.stopPropagation()}>
                             <input type="checkbox" checked={selectedPageIds.has(page.id)} onChange={() => {
                                const newSet = new Set(selectedPageIds);
                                if (newSet.has(page.id)) newSet.delete(page.id); else newSet.add(page.id);
                                setSelectedPageIds(newSet);
                             }} className="w-5 h-5 rounded border-slate-300 text-brand-600 focus:ring-brand-500 shadow-sm cursor-pointer" />
                          </div>

                          {/* Page Number Badge */}
                          <div className="absolute top-2 right-2 z-10 bg-slate-900/70 text-white text-xs px-2 py-0.5 rounded-full backdrop-blur-sm font-mono">
                             {index + 1}
                          </div>

                          {/* Thumbnail */}
                          <div className="aspect-[1/1.414] w-full overflow-hidden rounded-t-lg bg-slate-100 relative cursor-pointer" onClick={() => handleEditPage(page)}>
                             <img src={page.thumbnailUrl} className="w-full h-full object-contain" />
                             {/* Annotation Preview Overlay */}
                             <div className="absolute inset-0 pointer-events-none">
                                 {page.annotations.map(ann => {
                                     // Simplified render for preview
                                     const style = {
                                        position: 'absolute',
                                        left: `${(ann.x / page.originalWidth) * 100}%`,
                                        top: `${(ann.y / page.originalHeight) * 100}%`,
                                        width: ann.width ? `${(ann.width / page.originalWidth) * 100}%` : 'auto',
                                        height: ann.height ? `${(ann.height / page.originalHeight) * 100}%` : 'auto',
                                     };
                                     if(ann.type === 'highlight') return <div key={ann.id} style={{...style, backgroundColor: ann.color, opacity: 0.4}} />;
                                     if(ann.type === 'rect') return <div key={ann.id} style={{...style, border: `2px solid ${ann.color}`}} />;
                                     if(ann.type === 'circle') return <div key={ann.id} style={{...style, border: `2px solid ${ann.color}`, borderRadius: '50%'}} />;
                                     if(ann.type === 'cross') return <div key={ann.id} style={{...style, color: ann.color}}>X</div>; 
                                     if(ann.type === 'arrow') return <div key={ann.id} style={{...style, height:'2px', backgroundColor:ann.color, transformOrigin:'0 0', width:`${Math.sqrt(ann.width**2 + ann.height**2)/page.originalWidth*100}%`, transform:`rotate(${Math.atan2(ann.height, ann.width)}rad)`}} />;
                                     if(ann.type === 'text' || ann.type === 'callout' || ann.type === 'calloutCircle') return <div key={ann.id} style={{...style, fontSize:'8px', color: ann.color}}>{ann.text}</div>;
                                     if(ann.type === 'image') return <img key={ann.id} src={ann.imageData} style={{...style, objectFit:'contain'}} />;
                                     return null;
                                 })}
                             </div>
                             
                             <div className="absolute inset-0 bg-black/0 group-hover:bg-black/5 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                                 <div className="bg-white/90 text-brand-700 px-3 py-1 rounded-full shadow-sm text-sm font-medium flex items-center gap-1">
                                     <Edit3 size={14} /> 編集
                                 </div>
                             </div>
                          </div>

                          {/* Footer Actions */}
                          <div className="p-2 border-t border-slate-100 flex justify-around bg-slate-50 rounded-b-lg">
                             <button onClick={(e) => { e.stopPropagation(); setPages(pages.map(p => p.id === page.id ? { ...p, rotation: (p.rotation + 90) % 360 } : p)); }} className="p-1.5 text-slate-500 hover:text-brand-600 hover:bg-white rounded transition-colors" title="回転">
                                <RotateCw size={16} />
                             </button>
                             <button onClick={(e) => { e.stopPropagation(); if(confirm('削除しますか？')) { const newP = pages.filter(p => p.id !== page.id); setPages(applyPageNumbers(newP, pageNumMode)); } }} className="p-1.5 text-slate-500 hover:text-red-600 hover:bg-white rounded transition-colors" title="削除">
                                <Trash2 size={16} />
                             </button>
                          </div>
                       </div>
                    ))}
                 </div>
               )}
            </div>

            {/* Floating Delete Bar */}
            {selectedPageIds.size > 0 && (
                <div className="fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-900 text-white px-6 py-3 rounded-full shadow-xl flex items-center gap-4 z-30 animate-bounce-in">
                    <span className="font-medium">{selectedPageIds.size} ページ選択中</span>
                    <button onClick={handleDeletePages} className="bg-red-500 hover:bg-red-600 text-white px-4 py-1.5 rounded-full text-sm font-bold transition-colors">
                        削除する
                    </button>
                    <button onClick={() => setSelectedPageIds(new Set())} className="text-slate-400 hover:text-white">
                        <X size={20} />
                    </button>
                </div>
            )}
            
            {/* Drag Overlay */}
            {isDraggingFile && (
                <div className="fixed inset-0 bg-brand-500/90 z-50 flex flex-col items-center justify-center text-white backdrop-blur-sm pointer-events-none">
                    <FolderPlus size={80} className="mb-4 animate-bounce" />
                    <h2 className="text-3xl font-bold">ドロップしてファイルを追加</h2>
                </div>
            )}

            {/* Editor Modal */}
            {editorPage && (
               <AnnotationEditor 
                  page={editorPage.page} 
                  imageSrc={editorPage.highResUrl} 
                  onClose={() => setEditorPage(null)} 
                  onSave={handleSaveAnnotation} 
               />
            )}
            
            {/* Page Number Modal */}
            {showPageNumModal && (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center" onClick={() => setShowPageNumModal(false)}>
                    <div className="bg-white rounded-xl shadow-2xl p-6 w-80" onClick={e => e.stopPropagation()}>
                        <h3 className="text-lg font-bold text-slate-800 mb-4 flex items-center gap-2">
                            <Hash size={20} className="text-brand-600"/> ページ番号設定
                        </h3>
                        
                        <div className="space-y-3">
                            <button onClick={() => updatePageNumberMode('bottom-center')} className={`w-full p-3 rounded-lg border-2 flex items-center justify-between ${pageNumMode === 'bottom-center' ? 'border-brand-500 bg-brand-50' : 'border-slate-200 hover:border-brand-300'}`}>
                                <span className="font-medium">中央下 (フッター)</span>
                                {pageNumMode === 'bottom-center' && <Check size={18} className="text-brand-600" />}
                            </button>
                            <button onClick={() => updatePageNumberMode('bottom-right')} className={`w-full p-3 rounded-lg border-2 flex items-center justify-between ${pageNumMode === 'bottom-right' ? 'border-brand-500 bg-brand-50' : 'border-slate-200 hover:border-brand-300'}`}>
                                <span className="font-medium">右下</span>
                                {pageNumMode === 'bottom-right' && <Check size={18} className="text-brand-600" />}
                            </button>
                            
                            <hr className="my-2 border-slate-100"/>
                            
                            <button onClick={() => updatePageNumberMode('none')} className="w-full p-3 rounded-lg border-2 border-slate-200 hover:border-red-300 hover:bg-red-50 text-slate-600 hover:text-red-600 flex items-center justify-center gap-2">
                                <RefreshCcw size={16} /> リセット (番号削除)
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* Loading Overlay */}
            {isProcessing && (
                <div className="fixed inset-0 bg-white/80 z-50 flex flex-col items-center justify-center backdrop-blur-sm">
                    <div className="w-12 h-12 border-4 border-brand-200 border-t-brand-600 rounded-full animate-spin mb-4"></div>
                    <p className="text-brand-800 font-medium">処理中...</p>
                </div>
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>