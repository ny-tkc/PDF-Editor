<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Master Studio</title>
    <meta name="description" content="高度なPDF編集ツール。結合、ページ削除、回転、注釈（テキスト、赤枠、矢印）の追加が可能。日本語UI対応。" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
              }
            },
            animation: {
              'bounce-in': 'bounceIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards',
              'fade-in': 'fadeIn 0.1s ease-out forwards',
            },
            keyframes: {
              bounceIn: {
                '0%': { transform: 'translate(-50%, 100%)', opacity: 0 },
                '100%': { transform: 'translate(-50%, 0)', opacity: 1 },
              },
              fadeIn: {
                '0%': { opacity: 0, transform: 'scale(0.95)' },
                '100%': { opacity: 1, transform: 'scale(1)' },
              }
            },
            cursor: {
              'crosshair': 'crosshair',
              'text': 'text',
              'move': 'move',
            }
          }
        }
      }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF Libraries -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>

    <script>
      // PDF.js worker setup
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f5f9; }
      ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
      
      .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 0.2;
        line-height: 1.0;
        /* pointer-events will be handled dynamically in React */
      }
      .textLayer span {
        color: transparent;
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
      }
      ::selection {
        background: rgba(14, 165, 233, 0.3);
      }
      .preserve-3d {
        transform-style: preserve-3d;
      }
      /* Custom Cursor Classes */
      .cursor-draw-rect { cursor: crosshair; }
      .cursor-draw-text { cursor: text; }
    </style>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-100 text-slate-800">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useRef, useCallback, useMemo } = React;

      // --- ICONS ---
      const createIcon = (path) => (props) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={props.size || 24} 
          height={props.size || 24} 
          viewBox="0 0 24 24" 
          fill={props.fill || "none"} 
          stroke="currentColor" 
          strokeWidth={props.strokeWidth || 2} 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={props.className}
          {...props}
        >
          {path}
        </svg>
      );

      const Icons = {
        X: createIcon(<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>),
        Square: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        FilledSquare: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2" fill="currentColor"></rect>),
        Circle: createIcon(<circle cx="12" cy="12" r="10"></circle>),
        ArrowRight: createIcon(<><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></>),
        Type: createIcon(<><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></>),
        Move: createIcon(<><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></>),
        Check: createIcon(<polyline points="20 6 9 17 4 12"></polyline>),
        ImageIcon: createIcon(<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></>),
        ZoomIn: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        ZoomOut: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        Bold: createIcon(<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>),
        Upload: createIcon(<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></>),
        FileDown: createIcon(<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18v-6"></path><path d="m9 15 3 3 3-3"></path></>),
        Trash2: createIcon(<><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>),
        RotateCw: createIcon(<path d="M23 4v6h-6 M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>),
        Edit3: createIcon(<path d="M12 20h9 M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>),
        Copy: createIcon(<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></>),
        Plus: createIcon(<><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>),
        ChevronDown: createIcon(<polyline points="6 9 12 15 18 9"></polyline>),
        ArrowUpDown: createIcon(<><path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/></>),
        ArrowLeftRight: createIcon(<><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></>), 
        RefreshCcw: createIcon(<><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></>),
        Shapes: createIcon(<><path d="M3 3h18v18H3zM12 8l4 8H8z"/></>),
        Hash: createIcon(<><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></>),
        MessageSquare: createIcon(<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>),
        MessageCircle: createIcon(<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>),
        FolderPlus: createIcon(<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>),
        LayoutGrid: createIcon(<><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></>),
        Layers: createIcon(<><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></>),
        Columns: createIcon(<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>),
        ChevronLeft: createIcon(<polyline points="15 18 9 12 15 6"></polyline>),
        ChevronRight: createIcon(<polyline points="9 18 15 12 9 6"></polyline>),
        ChevronsLeft: createIcon(<><polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline></>),
        ChevronsRight: createIcon(<><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></>),
        Undo: createIcon(<><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></>),
        Redo: createIcon(<><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 3.7"/></>),
        Folder: createIcon(<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>),
        MoreHorizontal: createIcon(<><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></>),
        BringToFront: createIcon(<><rect x="14" y="14" width="8" height="8" rx="2" ry="2"></rect><rect x="2" y="2" width="8" height="8" rx="2" ry="2"></rect><path d="M14 2v8a2 2 0 0 1-2 2H4"></path></>),
        SendToBack: createIcon(<><rect x="14" y="14" width="8" height="8" rx="2" ry="2"></rect><rect x="2" y="2" width="8" height="8" rx="2" ry="2"></rect><path d="M7 14v1a2 2 0 0 0 2 2h1"></path></>),
      };
    
      const { 
        X, Square, FilledSquare, Circle, ArrowRight, Type, Move, Check, 
        ImageIcon, ZoomIn, ZoomOut, Bold, 
        Upload, FileDown, Trash2, RotateCw, Edit3, Copy, Plus, 
        ChevronDown, ArrowUpDown, ArrowLeftRight, RefreshCcw, Shapes,
        Hash, MessageSquare, MessageCircle, FolderPlus,
        LayoutGrid, Layers, Columns,
        ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight,
        Undo, Redo, Folder, MoreHorizontal, BringToFront, SendToBack
      } = Icons;

      const generateId = () => {
        if (typeof crypto !== 'undefined' && crypto.randomUUID && window.isSecureContext) {
          return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      };

      // --- UTILS ---
      const getBubblePathStr = (x, y, w, h, tail, type) => {
        const tx = x + tail.x;
        const ty = y + tail.y;
        
        if (type === 'calloutCircle') {
           const cx = x + w/2;
           const cy = y + h/2;
           const rx = Math.abs(w)/2;
           const ry = Math.abs(h)/2;
           const angle = Math.atan2(ty - cy, tx - cx);
           const px = cx + Math.cos(angle) * rx;
           const py = cy + Math.sin(angle) * ry;
           const px2 = cx + Math.cos(angle + 0.2) * rx;
           const py2 = cy + Math.sin(angle + 0.2) * ry;
           const px3 = cx + Math.cos(angle - 0.2) * rx;
           const py3 = cy + Math.sin(angle - 0.2) * ry;

           let d = `M ${cx+rx} ${cy} A ${rx} ${ry} 0 1 1 ${cx-rx} ${cy} A ${rx} ${ry} 0 1 1 ${cx+rx} ${cy}`;
           d += ` M ${px2} ${py2} L ${tx} ${ty} L ${px3} ${py3}`;
           return d;
        } else {
           const r = 10;
           const cx = x + w/2; 
           const cy = y + h/2;
           const dx = tx - cx; 
           const dy = ty - cy;
           
           let sector = 'bottom';
           if (Math.abs(dx) * h > Math.abs(dy) * w) {
              sector = dx > 0 ? 'right' : 'left';
           } else {
              sector = dy > 0 ? 'bottom' : 'top';
           }

           let d = `M ${x + r} ${y} L ${x + w - r} ${y} Q ${x + w} ${y} ${x + w} ${y + r}`;
           if (sector === 'right') {
              d += ` L ${x + w} ${y + h/2 - 10} L ${tx} ${ty} L ${x + w} ${y + h/2 + 10}`;
           }
           d += ` L ${x + w} ${y + h - r} Q ${x + w} ${y + h} ${x + w - r} ${y + h}`;
           if (sector === 'bottom') {
               d += ` L ${x + w/2 + 10} ${y + h} L ${tx} ${ty} L ${x + w/2 - 10} ${y + h}`;
           }
           d += ` L ${x + r} ${y + h} Q ${x} ${y + h} ${x} ${y + h - r}`;
           if (sector === 'left') {
               d += ` L ${x} ${y + h/2 + 10} L ${tx} ${ty} L ${x} ${y + h/2 - 10}`;
           }
           d += ` L ${x} ${y + r} Q ${x} ${y} ${x + r} ${y}`;
           if (sector === 'top') {
               d += ` L ${x + w/2 - 10} ${y} L ${tx} ${ty} L ${x + w/2 + 10} ${y}`;
           }
           d += ` Z`;
           return d;
        }
      };

      const loadPDF = async (file) => {
        let arrayBuffer = await file.arrayBuffer();
        let fileName = file.name;
        const isImage = file.type.startsWith('image/') || /\.(jpg|jpeg|png|webp)$/i.test(file.name);

        if (isImage && file.type !== 'application/pdf') {
          try {
            const pdfDoc = await PDFLib.PDFDocument.create();
            let image;
            if (file.type === 'image/jpeg' || file.type === 'image/jpg' || fileName.toLowerCase().endsWith('.jpg') || fileName.toLowerCase().endsWith('.jpeg')) {
              image = await pdfDoc.embedJpg(arrayBuffer);
            } else {
              try {
                 image = await pdfDoc.embedPng(arrayBuffer);
              } catch (e) {
                 image = await pdfDoc.embedJpg(arrayBuffer);
              }
            }
            const page = pdfDoc.addPage([image.width, image.height]);
            page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
            const pdfBytes = await pdfDoc.save();
            arrayBuffer = pdfBytes.buffer;
            fileName = fileName + ".pdf"; 
          } catch (e) {
            console.error("Image to PDF conversion failed", e);
            throw new Error("Unsupported image format.");
          }
        }

        const loadingTask = pdfjsLib.getDocument({
           data: arrayBuffer.slice(0),
           cMapUrl: 'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
           cMapPacked: true,
        });
        const pdf = await loadingTask.promise;
        const sourceId = generateId();
        const pages = [];

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const viewport = page.getViewport({ scale: 2.0 }); 
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport: viewport }).promise;

          pages.push({
            id: generateId(),
            sourcePdfId: sourceId,
            pageIndex: i,
            rotation: 0,
            thumbnailUrl: canvas.toDataURL(),
            originalWidth: viewport.width / 2.0,
            originalHeight: viewport.height / 2.0,
            annotations: []
          });
        }
        return { source: { id: sourceId, name: fileName, data: arrayBuffer }, pages };
      };

      const generateFinalPDF = async (pages, sources) => {
        const mergedPdf = await PDFLib.PDFDocument.create();
        for (const pageData of pages) {
          const source = sources.get(pageData.sourcePdfId);
          if (!source) continue;
          const sourcePdfDoc = await PDFLib.PDFDocument.load(source.data);
          const [copiedPage] = await mergedPdf.copyPages(sourcePdfDoc, [pageData.pageIndex]);
          
          const currentRotation = copiedPage.getRotation().angle;
          copiedPage.setRotation(PDFLib.degrees(currentRotation + pageData.rotation));

          if (pageData.annotations.length > 0) {
            const width = pageData.originalWidth;
            const height = pageData.originalHeight;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            if (ctx) {
              ctx.textBaseline = 'top'; 
              for (const ann of pageData.annotations) {
                 ctx.globalAlpha = 1.0; 
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type !== 'arrow') {
                     if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
                     if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                 }

                 if (ann.type === 'rect') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'filledRect') {
                   ctx.fillStyle = ann.color; ctx.fillRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'circle') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath();
                   ctx.ellipse(boxX + boxW/2, boxY + boxH/2, Math.abs(boxW)/2, Math.abs(boxH)/2, 0, 0, 2 * Math.PI);
                   ctx.stroke();
                 } else if (ann.type === 'cross') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath();
                   ctx.moveTo(boxX, boxY); ctx.lineTo(boxX + boxW, boxY + boxH);
                   ctx.moveTo(boxX + boxW, boxY); ctx.lineTo(boxX, boxY + boxH); ctx.stroke();
                 } else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 32;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 } else if ((ann.type === 'callout' || ann.type === 'calloutCircle') && ann.text) {
                   ctx.fillStyle = 'white'; ctx.strokeStyle = ann.color; ctx.lineWidth = 3;
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   const pathData = getBubblePathStr(boxX, boxY, boxW, boxH, tail, ann.type);
                   const p = new Path2D(pathData);
                   ctx.fill(p); ctx.stroke(p);
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 24;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   const metrics = ctx.measureText(ann.text);
                   const textX = boxX + (boxW - metrics.width)/2;
                   const textY = boxY + (boxH - fSize)/2;
                   ctx.fillText(ann.text, textX, textY);
                 } else if (ann.type === 'arrow') {
                   ctx.strokeStyle = ann.color; ctx.fillStyle = ann.color; ctx.lineWidth = 5;
                   const startX = ann.x; const startY = ann.y;
                   const endX = ann.x + ann.width; const endY = ann.y + ann.height;
                   const headLen = 20; 
                   const angle = Math.atan2(endY - startY, endX - startX);
                   ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
                   ctx.beginPath(); ctx.moveTo(endX, endY);
                   ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                   ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                   ctx.closePath(); ctx.fill();
                 } else if (ann.type === 'image' && ann.imageData) {
                     await new Promise((resolve) => {
                         const img = new Image();
                         img.onload = () => { ctx.drawImage(img, boxX, boxY, boxW, boxH); resolve(null); };
                         img.src = ann.imageData; 
                     });
                 }
              }
              const pngImageBytes = await fetch(canvas.toDataURL('image/png')).then(res => res.arrayBuffer());
              const pngImage = await mergedPdf.embedPng(pngImageBytes);
              copiedPage.drawImage(pngImage, { x: 0, y: 0, width: copiedPage.getWidth(), height: copiedPage.getHeight() });
            }
          }
          mergedPdf.addPage(copiedPage);
        }
        return await mergedPdf.save();
      };

      const renderHighResPage = async (pageData, source) => {
          const loadingTask = pdfjsLib.getDocument({ 
              data: source.data.slice(0),
              cMapUrl: 'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
              cMapPacked: true,
          });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(pageData.pageIndex + 1);
          const viewport = page.getViewport({ scale: 3.0, rotation: pageData.rotation });
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport: viewport }).promise;
          const textContent = await page.getTextContent();
          return { dataUrl: canvas.toDataURL(), textContent, viewport };
      };

      // --- COMPONENTS ---

      const AnnotationEditor = ({ page, imageSrc, textContent, viewportInfo, onClose, onSave }) => {
        const [annotations, setAnnotations] = useState(page.annotations || []);
        const [history, setHistory] = useState([]);
        const [redoStack, setRedoStack] = useState([]);
        const [tool, setTool] = useState('select');
        const [showShapeMenu, setShowShapeMenu] = useState(false);
        const [showTextMenu, setShowTextMenu] = useState(false);
        const [color, setColor] = useState('#ef4444');
        const [fontSize, setFontSize] = useState(32);
        const [fontFamily, setFontFamily] = useState('Meiryo UI');
        const [isBold, setIsBold] = useState(false);
        const [zoom, setZoom] = useState(0.8);
        const [isDrawing, setIsDrawing] = useState(false);
        const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 }); 
        const [currentAnnotation, setCurrentAnnotation] = useState(null); 
        const [selectedIds, setSelectedIds] = useState(new Set()); 
        const [interactionMode, setInteractionMode] = useState('none');
        const [resizeHandle, setResizeHandle] = useState(null);
        const [interactionStartPos, setInteractionStartPos] = useState({ x: 0, y: 0 });
        const [initialAnnStates, setInitialAnnStates] = useState(new Map());
        const [selectionBox, setSelectionBox] = useState(null);
        const [contextMenu, setContextMenu] = useState(null);

        const imgRef = useRef(null);
        const containerRef = useRef(null);
        const fileInputRef = useRef(null);
        const textMenuRef = useRef(null);
        const shapeMenuRef = useRef(null);
        const initialAnnotationsStr = useRef(JSON.stringify(page.annotations || []));

        useEffect(() => {
           const handleClickOutside = (event) => {
               if (textMenuRef.current && !textMenuRef.current.contains(event.target)) setShowTextMenu(false);
               if (shapeMenuRef.current && !shapeMenuRef.current.contains(event.target)) setShowShapeMenu(false);
               if (contextMenu && !event.target.closest('.context-menu')) setContextMenu(null);
           };
           document.addEventListener("mousedown", handleClickOutside);
           return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [contextMenu]);

        const saveToHistory = (newAnns) => { setHistory(prev => [...prev, annotations]); setRedoStack([]); setAnnotations(newAnns); };
        const undo = () => {
            if (history.length === 0) return;
            const previous = history[history.length - 1];
            setRedoStack(prev => [annotations, ...prev]); setAnnotations(previous); setHistory(history.slice(0, -1));
        };
        const redo = () => {
            if (redoStack.length === 0) return;
            const next = redoStack[0];
            setHistory(prev => [...prev, annotations]); setAnnotations(next); setRedoStack(redoStack.slice(1));
        };
        const deleteSelected = () => {
            if (selectedIds.size === 0) return;
            const remaining = annotations.filter(a => !selectedIds.has(a.id));
            saveToHistory(remaining); setSelectedIds(new Set()); setContextMenu(null);
        };
        const bringToFront = () => {
            if (selectedIds.size === 0) return;
            const selected = annotations.filter(a => selectedIds.has(a.id));
            const unselected = annotations.filter(a => !selectedIds.has(a.id));
            saveToHistory([...unselected, ...selected]); setContextMenu(null);
        };
        const sendToBack = () => {
            if (selectedIds.size === 0) return;
            const selected = annotations.filter(a => selectedIds.has(a.id));
            const unselected = annotations.filter(a => !selectedIds.has(a.id));
            saveToHistory([...selected, ...unselected]); setContextMenu(null);
        };

        const handleClipboardCopy = async () => {
             const canvas = document.createElement('canvas');
             canvas.width = page.originalWidth; canvas.height = page.originalHeight;
             const ctx = canvas.getContext('2d');
             const bgImg = new Image();
             bgImg.crossOrigin = "anonymous";
             bgImg.src = imageSrc;
             await new Promise(resolve => { bgImg.onload = resolve; });
             ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
             ctx.textBaseline = 'top';
             for (const ann of annotations) {
                 ctx.globalAlpha = 1.0; 
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type !== 'arrow') { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
                 
                 if (ann.type === 'rect') { ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH); }
                 else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   ctx.font = `${fontWeight} ${ann.fontSize || 32}px ${ann.fontFamily || 'sans-serif'}`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 }
                 else if (ann.type === 'image' && ann.imageData) {
                     await new Promise((resolve) => {
                         const img = new Image();
                         img.onload = () => { ctx.drawImage(img, boxX, boxY, boxW, boxH); resolve(null); };
                         img.src = ann.imageData; 
                     });
                 }
             }
             canvas.toBlob(blob => { if (blob) { navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]).then(() => alert("画像をクリップボードにコピーしました")); } }, 'image/png');
        };

        const fitWidth = () => { if (containerRef.current) setZoom((containerRef.current.clientWidth - 64) / page.originalWidth); };
        const fitHeight = () => { if (containerRef.current) setZoom((containerRef.current.clientHeight - 64) / page.originalHeight); };
        useEffect(() => { fitHeight(); }, []);
        const handleClose = () => {
             if (JSON.stringify(annotations) !== initialAnnotationsStr.current && !confirm("変更内容が保存されていません。破棄してもよろしいですか？")) return;
             onClose();
        };

        useEffect(() => {
          if (selectedIds.size === 1) {
              const ann = annotations.find(a => a.id === Array.from(selectedIds)[0]);
              if (ann) {
                  if (['text','callout','calloutCircle'].includes(ann.type)) { setFontSize(ann.fontSize); setIsBold(ann.fontWeight === 'bold'); setFontFamily(ann.fontFamily); }
                  if (ann.type !== 'image') setColor(ann.color);
              }
          }
        }, [selectedIds]);

        useEffect(() => {
            const handleKeyDown = (e) => {
                if (selectedIds.size === 0) return;
                const step = e.shiftKey ? 50 : 10;
                let dx = 0; let dy = 0;
                if (e.key === 'ArrowUp') dy = -step; else if (e.key === 'ArrowDown') dy = step; else if (e.key === 'ArrowLeft') dx = -step; else if (e.key === 'ArrowRight') dx = step;
                else if (e.key === 'Delete' || e.key === 'Backspace') { deleteSelected(); return; }
                else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); e.shiftKey ? redo() : undo(); return; }
                else if (e.key === 'y' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); redo(); return; }
                else return;
                if (dx !== 0 || dy !== 0) { e.preventDefault(); setAnnotations(prev => prev.map(a => selectedIds.has(a.id) ? { ...a, x: a.x + dx, y: a.y + dy } : a)); }
            };
            window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedIds, history, redoStack]);

        const getPointerPos = (e) => {
          if (!containerRef.current) return { x: 0, y: 0 };
          const rect = containerRef.current.getBoundingClientRect();
          const scaleX = page.originalWidth / rect.width;
          const scaleY = page.originalHeight / rect.height;
          return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        };
        const selectTool = (t) => {
           setSelectedIds(new Set()); setTool(t);
           const defaults = { rect: '#ef4444', filledRect: '#000000', circle: '#ef4444', cross: '#ef4444', arrow: '#ef4444', text: '#000000', callout: '#000000', calloutCircle: '#000000' };
           if (defaults[t]) setColor(defaults[t]);
        };

        // --- NEW MOUSE HANDLERS (Simpler, Robust) ---
        const handleMouseDown = (e) => {
          if (e.button === 2) return; 
          if (e.target.closest('button') || e.target.closest('.cursor-nw-resize') || e.target.closest('.cursor-crosshair') || e.target.closest('.context-menu')) return; 
          
          const { x, y } = getPointerPos(e); 
          setDragStartPos({ x, y });

          if (tool === 'select') {
             // 1. Check intersection with annotations (reverse order to hit top-most first)
             const clickedId = [...annotations].reverse().find(ann => {
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type === 'arrow') {
                     const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height);
                     const maxX = Math.max(ann.x, ann.x + ann.width); const maxY = Math.max(ann.y, ann.y + ann.height);
                     boxX = minX - 10; boxY = minY - 10; boxW = maxX - minX + 20; boxH = maxY - minY + 20;
                 } else { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
                 if (ann.type === 'text') { const approxW = (ann.text.length * ann.fontSize) || 100; const approxH = ann.fontSize || 32; return x >= boxX && x <= boxX + approxW && y >= boxY && y <= boxY + approxH; }
                 return x >= boxX && x <= boxX + boxW && y >= boxY && y <= boxY + boxH;
             })?.id;

             if (clickedId) {
                 if (e.ctrlKey || e.metaKey) { 
                     const newSet = new Set(selectedIds); 
                     if (newSet.has(clickedId)) newSet.delete(clickedId); else newSet.add(clickedId); 
                     setSelectedIds(newSet);
                 } else { 
                     // IMPORTANT: If clicking an item that is ALREADY selected, do NOT clear other selections (allows moving group)
                     if (!selectedIds.has(clickedId)) {
                        setSelectedIds(new Set([clickedId])); 
                     }
                 }
                 setInteractionMode('moving'); 
                 setInteractionStartPos({ x, y }); 
                 const stateMap = new Map(); annotations.forEach(a => stateMap.set(a.id, {...a})); setInitialAnnStates(stateMap); 
             } else { 
                 // Clicked on empty space -> Start Box Selection
                 if (!e.ctrlKey && !e.metaKey) setSelectedIds(new Set()); 
                 setSelectionBox({ x, y, w: 0, h: 0 }); 
                 setInteractionMode('selecting'); 
             }
             setContextMenu(null);
          } else {
             // Drawing Tools
             // PREVENT DEFAULT TO STOP NATIVE DRAGGING
             e.preventDefault();

             setIsDrawing(true);
             
             // Immediate interactions for Text/Callout/Image
             if (['text','callout','calloutCircle'].includes(tool)) {
                 const text = prompt("テキストを入力してください:", "");
                 if (text && text.trim() !== "") {
                   const newAnn = { id: generateId(), type: tool, x, y, width: tool !== 'text' ? 200 : undefined, height: tool !== 'text' ? 100 : undefined, text, color, fontSize, fontWeight: isBold ? 'bold' : 'normal', fontFamily: fontFamily, tailTip: tool !== 'text' ? { x: 100, y: 150 } : undefined };
                   saveToHistory([...annotations, newAnn]); setSelectedIds(new Set([newAnn.id]));
                   setTool('select'); 
                 }
                 setIsDrawing(false);
             } else if (tool === 'image') {
                 fileInputRef.current?.click(); 
                 setIsDrawing(false);
             } else {
                 // Initialize shape for dragging
                 setCurrentAnnotation({ type: tool, x, y, width: 0, height: 0, color });
             }
          }
        };

        const handleMouseMove = (e) => {
          const { x, y } = getPointerPos(e);
          
          if (interactionMode === 'moving' && selectedIds.size > 0) {
              const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
              setAnnotations(prev => prev.map(ann => selectedIds.has(ann.id) && initialAnnStates.get(ann.id) ? { ...ann, x: initialAnnStates.get(ann.id).x + dx, y: initialAnnStates.get(ann.id).y + dy } : ann));
          } else if (interactionMode === 'resizing' && selectedIds.size === 1) {
              const id = Array.from(selectedIds)[0]; const initial = initialAnnStates.get(id); if (!initial) return;
              const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
              setAnnotations(prev => prev.map(ann => {
                  if (ann.id !== id) return ann;
                  if (['text','callout','calloutCircle'].includes(ann.type)) {
                       const scaleFactor = 1 + (dy / (initial.height || 100)); 
                       const newSize = Math.max(10, Math.floor(initial.fontSize * scaleFactor));
                       let newW = initial.width || 0; let newH = initial.height || 0;
                       if (ann.type !== 'text') { 
                           if (resizeHandle.includes('e')) newW += dx; if (resizeHandle.includes('w')) newW -= dx; if (resizeHandle.includes('s')) newH += dy; if (resizeHandle.includes('n')) newH -= dy; 
                       }
                       let newTail = ann.tailTip;
                       if (initial.tailTip && initial.width && initial.height) {
                           const ratioX = newW / initial.width; const ratioY = newH / initial.height;
                           newTail = { x: initial.tailTip.x * ratioX, y: initial.tailTip.y * ratioY };
                       }
                       return { ...ann, fontSize: newSize, width: newW, height: newH, tailTip: newTail };
                  }
                  let newX = initial.x; let newY = initial.y; let newW = initial.width || 0; let newH = initial.height || 0;
                  if (resizeHandle.includes('e')) newW += dx; if (resizeHandle.includes('w')) { newX += dx; newW -= dx; } if (resizeHandle.includes('s')) newH += dy; if (resizeHandle.includes('n')) { newY += dy; newH -= dy; }
                  return { ...ann, x: newX, y: newY, width: newW, height: newH };
              }));
          } else if (interactionMode === 'tail' && selectedIds.size === 1) {
             const id = Array.from(selectedIds)[0]; const initial = initialAnnStates.get(id); if (!initial) return;
             const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
             setAnnotations(prev => prev.map(ann => ann.id !== id ? ann : { ...ann, tailTip: { x: (initial.tailTip || {x: initial.width/2, y: initial.height+50}).x + dx, y: (initial.tailTip || {x: initial.width/2, y: initial.height+50}).y + dy } }));
          } else if (interactionMode === 'selecting') {
             setSelectionBox({ x: Math.min(dragStartPos.x, x), y: Math.min(dragStartPos.y, y), w: Math.abs(x - dragStartPos.x), h: Math.abs(y - dragStartPos.y) });
          } else if (isDrawing && currentAnnotation) {
             setCurrentAnnotation(prev => ({ ...prev, width: x - dragStartPos.x, height: y - dragStartPos.y }));
          }
        };

        const handleMouseUp = () => {
          if (['moving','resizing','tail'].includes(interactionMode)) saveToHistory(annotations);
          
          if (interactionMode === 'selecting' && selectionBox) {
              const { x, y, w, h } = selectionBox; const newSelection = new Set(selectedIds);
              annotations.forEach(ann => {
                 let boxX = ann.x; let boxY = ann.y; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type === 'text') { boxW = 100; boxH = 32; } 
                 if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                 // Check intersection
                 if (x < boxX + boxW && x + w > boxX && y < boxY + boxH && y + h > boxY) {
                     newSelection.add(ann.id);
                 }
              }); 
              setSelectedIds(newSelection); 
              setSelectionBox(null);
          }

          if (isDrawing && currentAnnotation) {
              // Finalize Shape
              const newAnn = { 
                  id: generateId(), type: currentAnnotation.type, x: dragStartPos.x, y: dragStartPos.y, 
                  width: currentAnnotation.width || 100, height: currentAnnotation.height || 100, 
                  color: currentAnnotation.color 
              };
              // Special default for Arrow
              if (currentAnnotation.type === 'arrow' && currentAnnotation.width === 0 && currentAnnotation.height === 0) {
                   newAnn.width = 100; newAnn.height = 0;
              }
              saveToHistory([...annotations, newAnn]); 
              setSelectedIds(new Set([newAnn.id]));
              setTool('select'); 
          }

          setInteractionMode('none'); setResizeHandle(null); setInitialAnnStates(new Map()); setIsDrawing(false); setCurrentAnnotation(null);
        };

        const handleResizeStart = (e, handle, id) => { e.stopPropagation(); e.preventDefault(); setSelectedIds(new Set([id])); setInteractionMode('resizing'); setResizeHandle(handle); setInteractionStartPos(getPointerPos(e)); const stateMap = new Map(); stateMap.set(id, {...annotations.find(a => a.id === id)}); setInitialAnnStates(stateMap); };
        const handleTailDragStart = (e, id) => { e.stopPropagation(); e.preventDefault(); setSelectedIds(new Set([id])); setInteractionMode('tail'); setInteractionStartPos(getPointerPos(e)); const stateMap = new Map(); stateMap.set(id, {...annotations.find(a => a.id === id)}); setInitialAnnStates(stateMap); };
        
        const handleEditorDrop = (e) => {
            e.preventDefault(); e.stopPropagation();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                const file = e.dataTransfer.files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const { x, y } = getPointerPos(e);
                        const newAnn = { id: generateId(), type: 'image', x, y, width: 200, height: 200, imageData: evt.target.result };
                        saveToHistory([...annotations, newAnn]); setSelectedIds(new Set([newAnn.id])); setTool('select');
                    };
                    reader.readAsDataURL(file);
                }
            }
        };

        const renderAnnotation = (ann, isPreview = false) => {
           const isSelected = !isPreview && selectedIds.has(ann.id);
           let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
           if (ann.type !== 'arrow') { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
           else { const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height); boxX = minX; boxY = minY; boxW = Math.max(ann.x, ann.x + ann.width) - minX; boxH = Math.max(ann.y, ann.y + ann.height) - minY; }
           if (ann.type === 'text') { boxW = undefined; boxH = undefined; }
           const style = { position: 'absolute', left: `${(boxX / page.originalWidth) * 100}%`, top: `${(boxY / page.originalHeight) * 100}%`, width: boxW !== undefined ? `${(boxW / page.originalWidth) * 100}%` : 'auto', height: boxH !== undefined ? `${(boxH / page.originalHeight) * 100}%` : 'auto', pointerEvents: tool === 'select' && !isPreview ? 'auto' : 'none', cursor: tool === 'select' ? 'move' : 'crosshair', zIndex: isPreview ? 20 : (isSelected ? 30 : 10), outline: isSelected ? '2px dashed #0ea5e9' : 'none', };
           const renderHandles = () => {
               if (!isSelected || !ann.id || selectedIds.size > 1) return null;
               const hStyle = "absolute w-3 h-3 bg-white border border-brand-500 rounded-full z-50 pointer-events-auto";
               return ( <> <div className={`${hStyle} -top-1.5 -left-1.5 cursor-nw-resize`} onMouseDown={(e) => handleResizeStart(e, 'nw', ann.id)} /> <div className={`${hStyle} -top-1.5 -right-1.5 cursor-ne-resize`} onMouseDown={(e) => handleResizeStart(e, 'ne', ann.id)} /> <div className={`${hStyle} -bottom-1.5 -left-1.5 cursor-sw-resize`} onMouseDown={(e) => handleResizeStart(e, 'sw', ann.id)} /> <div className={`${hStyle} -bottom-1.5 -right-1.5 cursor-se-resize`} onMouseDown={(e) => handleResizeStart(e, 'se', ann.id)} /> {(ann.type === 'callout' || ann.type === 'calloutCircle') && ann.tailTip && ( <div className="absolute w-4 h-4 bg-yellow-400 border border-black rounded-full z-50 cursor-crosshair shadow-sm pointer-events-auto" style={{ left: `${(ann.tailTip.x / boxW) * 100}%`, top: `${(ann.tailTip.y / boxH) * 100}%`, transform: 'translate(-50%, -50%)' }} onMouseDown={(e) => handleTailDragStart(e, ann.id)} /> )} </> );
           }
           const renderContent = () => {
               if (ann.type === 'arrow') {
                   const globalStartX = ann.x; const globalStartY = ann.y; const globalEndX = ann.x + ann.width; const globalEndY = ann.y + ann.height;
                   const minX = Math.min(globalStartX, globalEndX); const minY = Math.min(globalStartY, globalEndY);
                   const headLen = 20 * (1/zoom * 0.5 + 0.5); const angle = Math.atan2(globalEndY - globalStartY, globalEndX - globalStartX);
                   return ( <svg width="100%" height="100%" style={{ overflow: 'visible', pointerEvents: 'none' }}> <line x1={globalStartX - minX} y1={globalStartY - minY} x2={globalEndX - minX} y2={globalEndY - minY} stroke="transparent" strokeWidth="20" style={{ pointerEvents: 'stroke' }} /> <line x1={globalStartX - minX} y1={globalStartY - minY} x2={globalEndX - minX} y2={globalEndY - minY} stroke={ann.color} strokeWidth="5" /> <polygon points={`${globalEndX - minX},${globalEndY - minY} ${(globalEndX - minX) - headLen * Math.cos(angle - Math.PI / 6)},${(globalEndY - minY) - headLen * Math.sin(angle - Math.PI / 6)} ${(globalEndX - minX) - headLen * Math.cos(angle + Math.PI / 6)},${(globalEndY - minY) - headLen * Math.sin(angle + Math.PI / 6)}`} fill={ann.color} /> </svg> );
               }
               if (ann.type === 'callout' || ann.type === 'calloutCircle') {
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   return ( <div style={{ width: '100%', height: '100%', overflow: 'visible' }}> <svg width="1" height="1" style={{ overflow: 'visible', width: '100%', height: '100%' }}> <path d={getBubblePathStr(0, 0, boxW, boxH, tail, ann.type)} fill="white" stroke={ann.color} strokeWidth="2" vectorEffect="non-scaling-stroke" /> </svg> <div style={{ position:'absolute', inset:0, display:'flex', alignItems:'center', justifyContent:'center', pointerEvents:'none' }}> <span style={{ color: ann.color, fontSize: `${(ann.fontSize || 24) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily }}>{ann.text}</span> </div> </div> )
               }
               if (ann.type === 'text') return <div style={{ color: ann.color, fontSize: `${(ann.fontSize || 32) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily, whiteSpace: 'nowrap', textShadow: '0 0 3px white', padding:'4px', lineHeight:1 }}>{ann.text}</div>;
               if (ann.type === 'circle') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}`, borderRadius: '50%' }} />;
               if (ann.type === 'cross') return <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"><line x1="0" y1="0" x2="100" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/><line x1="100" y1="0" x2="0" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/></svg>;
               if (ann.type === 'image') return <img src={ann.imageData} className="w-full h-full object-contain" draggable={false} />;
               if (ann.type === 'rect') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}` }} />;
               if (ann.type === 'filledRect') return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color }} />;
               return null;
           }
           return ( <div key={ann.id || 'preview'} style={style} onMouseDown={(e) => ann.id && !isPreview && handleMouseDown(e)} onContextMenu={(e) => !isPreview && handleContextMenu(e, ann.id)}> {renderContent()} {renderHandles()} </div> );
        };
        
        // Define tool cursor class
        const getCursorClass = () => {
             if (tool === 'select') return '';
             if (tool === 'text' || tool === 'callout' || tool === 'calloutCircle') return 'cursor-text';
             return 'cursor-crosshair';
        };

        return (
          <div className="fixed inset-0 z-50 bg-gray-100 flex flex-col">
            <div className="bg-white border-b px-4 py-2 flex items-center justify-between shadow-sm z-[60] relative">
              <div className="flex items-center space-x-2">
                 <button onClick={handleClose} className="p-2 hover:bg-gray-100 rounded text-gray-600"><X size={20} /></button>
                 <span className="font-bold text-gray-700">ページ {page.pageIndex + 1} の編集</span>
                 <div className="h-6 w-px bg-gray-300 mx-2"></div>
                 <button onClick={undo} disabled={history.length === 0} className={`p-2 rounded ${history.length===0 ? 'text-gray-300' : 'hover:bg-gray-100 text-gray-600'}`}><Undo size={20} /></button>
                 <button onClick={redo} disabled={redoStack.length === 0} className={`p-2 rounded ${redoStack.length===0 ? 'text-gray-300' : 'hover:bg-gray-100 text-gray-600'}`}><Redo size={20} /></button>
              </div>
              
              <div className="flex items-center space-x-2">
                 <button onClick={() => selectTool('select')} className={`p-2 rounded ${tool === 'select' ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`} title="移動・選択"><Move size={20} /></button>
                 <div className="relative" ref={textMenuRef}>
                    <button onClick={() => { setShowTextMenu(!showTextMenu); setShowShapeMenu(false); }} className={`p-2 rounded flex items-center ${['text','callout','calloutCircle'].includes(tool) ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`} title="テキスト追加"><Type size={20} /><ChevronDown size={14} className="ml-1"/></button>
                    {showTextMenu && (
                        <div className="absolute top-full left-0 mt-1 w-56 bg-white border rounded shadow-lg z-50 p-1">
                           <button onClick={() => { selectTool('text'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Type size={16} className="mr-2"/> テキスト</button>
                           <button onClick={() => { selectTool('callout'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><MessageSquare size={16} className="mr-2"/> 吹き出し (四角)</button>
                           <button onClick={() => { selectTool('calloutCircle'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><MessageCircle size={16} className="mr-2"/> 吹き出し (円)</button>
                        </div>
                    )}
                 </div>
                 <div className="relative" ref={shapeMenuRef}>
                    <button onClick={() => { setShowShapeMenu(!showShapeMenu); setShowTextMenu(false); }} className={`p-2 rounded flex items-center ${['rect','filledRect','circle','cross','arrow'].includes(tool) ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`} title="図形追加"><Shapes size={20} /><ChevronDown size={14} className="ml-1"/></button>
                    {showShapeMenu && (
                        <div className="absolute top-full left-0 mt-1 w-56 bg-white border rounded shadow-lg z-50 p-1">
                           <button onClick={() => { selectTool('rect'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Square size={16} className="mr-2"/> □ 長方形 (枠)</button>
                           <button onClick={() => { selectTool('filledRect'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><FilledSquare size={16} className="mr-2"/> ■ 長方形 (塗り)</button>
                           <button onClick={() => { selectTool('circle'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Circle size={16} className="mr-2"/> 〇 円</button>
                           <button onClick={() => { selectTool('cross'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><X size={16} className="mr-2"/> × バツ</button>
                           <button onClick={() => { selectTool('arrow'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><ArrowRight size={16} className="mr-2"/> 矢印</button>
                        </div>
                    )}
                 </div>
                 <button onClick={() => selectTool('image')} className={`p-2 rounded ${tool === 'image' ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`} title="画像追加"><ImageIcon size={20} /></button>
                 <div className="h-6 w-px bg-gray-300 mx-2"></div>
                 <input type="color" value={color} onChange={(e) => { setColor(e.target.value); updateSelectionStyle('color', e.target.value); }} className="w-8 h-8 rounded cursor-pointer border-0 p-0" title="色を選択" />
                 <div className="flex items-center border rounded px-2 bg-gray-50">
                    <span className="text-xs mr-1 text-gray-500">Tt</span>
                    <input type="number" min="8" max="200" step="4" value={fontSize} onChange={(e) => { const v = Math.floor(Number(e.target.value)); setFontSize(v); updateSelectionStyle('fontSize', v); }} className="w-14 text-center bg-transparent outline-none text-sm" />
                 </div>
                 <select value={fontFamily} onChange={(e) => { setFontFamily(e.target.value); updateSelectionStyle('fontFamily', e.target.value); }} className="text-sm border rounded px-1 py-1 w-24">
                    <option value="Meiryo UI">メイリオ</option>
                    <option value="sans-serif">ゴシック</option>
                    <option value="serif">明朝</option>
                    <option value="monospace">等幅</option>
                 </select>
                 <button onClick={() => { setIsBold(!isBold); updateSelectionStyle('fontWeight', !isBold ? 'bold' : 'normal'); }} className={`p-2 rounded ${isBold ? 'bg-gray-200' : 'hover:bg-gray-100'}`}><Bold size={20} /></button>
              </div>

              <div className="flex items-center space-x-2">
                  <button onClick={handleClipboardCopy} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded text-sm flex items-center mr-2"><Copy size={16} className="mr-1"/> コピー</button>
                  <button onClick={() => onSave(annotations)} className="bg-brand-600 hover:bg-brand-700 text-white px-4 py-2 rounded flex items-center"><Check size={20} className="mr-2" /> 完了</button>
              </div>
            </div>

            <div className="flex-1 overflow-auto relative bg-gray-200" onClick={() => { if (selectedIds.size > 0 && interactionMode === 'none') setSelectedIds(new Set()); }}>
               <div className="min-h-full flex items-center justify-center p-8">
                   <div 
                      ref={containerRef}
                      className={`relative bg-white shadow-2xl transition-transform duration-200 ease-out ${getCursorClass()}`}
                      style={{ width: page.originalWidth, height: page.originalHeight, transform: `scale(${zoom})`, transformOrigin: 'center top' }}
                      onMouseDown={handleMouseDown}
                      onMouseMove={handleMouseMove}
                      onMouseUp={handleMouseUp}
                      onDragStart={(e) => e.preventDefault()}
                      onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); }}
                      onDrop={handleEditorDrop} 
                   >
                       <img ref={imgRef} src={imageSrc} className="w-full h-full pointer-events-none select-none" alt="" draggable="false" onDragStart={(e) => e.preventDefault()} />
                       <div className="textLayer" style={{ pointerEvents: 'none' }}>
                           {/* Text selection disabled when drawing to prevent issues */}
                           {tool === 'select' && textContent?.items?.map((item, i) => (
                             <span key={i} style={{ left: `${item.transform[4]}px`, top: `${page.originalHeight - item.transform[5] - item.height}px`, fontSize: `${item.height}px`, fontFamily: item.fontName, width: `${item.width}px`, height: `${item.height}px`, pointerEvents:'auto' }}>{item.str}</span>
                           ))}
                       </div>
                       {annotations.map(ann => renderAnnotation(ann))}
                       {currentAnnotation && renderAnnotation(currentAnnotation, true)}
                       {selectionBox && ( <div className="absolute border-2 border-brand-500 border-dashed bg-brand-500/10 pointer-events-none z-50" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }} /> )}
                       {!imageSrc && ( <div className="absolute inset-0 flex items-center justify-center bg-gray-50 bg-opacity-90 z-40 cursor-pointer hover:bg-gray-100" onClick={() => fileInputRef.current?.click()} > <div className="text-center text-gray-400"> <ImageIcon size={48} className="mx-auto mb-2 opacity-50"/> <p>画像をドロップ または クリックして追加</p> </div> </div> )}
                   </div>
               </div>
            </div>
            
            {/* Context Menu */}
            {contextMenu && (
                <div 
                    className="context-menu fixed bg-white rounded-lg shadow-xl border z-[70] py-1 min-w-[180px] animate-fade-in"
                    style={{ left: contextMenu.x, top: contextMenu.y }}
                >
                    <div className="px-3 py-2 border-b flex items-center justify-between">
                         <span className="text-xs font-bold text-gray-500">編集</span>
                         <button onClick={() => setContextMenu(null)}><X size={14}/></button>
                    </div>
                    <button onClick={bringToFront} className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center text-sm"><BringToFront size={16} className="mr-2"/> 最前面へ移動</button>
                    <button onClick={sendToBack} className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center text-sm"><SendToBack size={16} className="mr-2"/> 最背面へ移動</button>
                    <div className="h-px bg-gray-100 my-1"></div>
                    <button onClick={deleteSelected} className="w-full text-left px-4 py-2 hover:bg-red-50 text-red-600 flex items-center text-sm"><Trash2 size={16} className="mr-2"/> 削除</button>
                </div>
            )}

            {/* Zoom Controls */}
            <div className="absolute right-4 bottom-4 flex flex-col space-y-2 bg-white rounded-lg shadow-lg p-1 border z-[60]">
               <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="p-2 hover:bg-gray-100 rounded"><ZoomIn size={20}/></button>
               <span className="text-xs text-center font-mono">{Math.round(zoom * 100)}%</span>
               <button onClick={() => setZoom(z => Math.max(0.1, z - 0.1))} className="p-2 hover:bg-gray-100 rounded"><ZoomOut size={20}/></button>
               <div className="h-px bg-gray-200 my-1"></div>
               <button onClick={fitWidth} className="p-2 hover:bg-gray-100 rounded" title="横幅に合わせる"><ArrowLeftRight size={20} className="rotate-45" /></button>
               <button onClick={fitHeight} className="p-2 hover:bg-gray-100 rounded" title="縦幅に合わせる"><ArrowUpDown size={20} /></button>
            </div>
            <input type="file" ref={fileInputRef} accept="image/*" className="hidden" onChange={(e) => { if (e.target.files?.[0]) { /* image load */ } }} />
          </div>
        );
      };

      const App = () => {
        const [pages, setPages] = useState([]);
        const [sources, setSources] = useState(new Map());
        const [editingPageId, setEditingPageId] = useState(null);
        const [editingData, setEditingData] = useState(null);
        const [viewMode, setViewMode] = useState('grid'); // 'grid', 'stack', 'carousel', 'folder'
        const [focusedPageIndex, setFocusedPageIndex] = useState(0);
        const [selectedPageIds, setSelectedPageIds] = useState(new Set());
        const [pageHistory, setPageHistory] = useState([]);
        
        // Page Numbering State
        const [showPageNumModal, setShowPageNumModal] = useState(false);
        const [pageNumPosition, setPageNumPosition] = useState('bottom-center');
        
        const fileInputRef = useRef(null);
        const carouselRef = useRef(null);

        // Group Pages by Source
        const groupedPages = useMemo(() => {
           const groups = new Map();
           pages.forEach(p => {
               if (!groups.has(p.sourcePdfId)) groups.set(p.sourcePdfId, []);
               groups.get(p.sourcePdfId).push(p);
           });
           return Array.from(groups.values());
        }, [pages]);

        const pushPageHistory = () => {
             setPageHistory(prev => [...prev.slice(-19), JSON.stringify(pages)]);
        };
        const undoPages = () => {
             if (pageHistory.length === 0) return;
             const prev = JSON.parse(pageHistory[pageHistory.length - 1]);
             setPageHistory(prevH => prevH.slice(0, -1));
             setPages(prev);
        };

        const handleFileUpload = async (e) => {
          const files = Array.from(e.target.files);
          if (files.length === 0) return;
          pushPageHistory();
          const newSources = new Map(sources);
          let newPages = [...pages];

          for (const file of files) {
            try {
              const { source, pages: loadedPages } = await loadPDF(file);
              newSources.set(source.id, source);
              newPages = [...newPages, ...loadedPages];
            } catch (err) {
              console.error(err);
              alert(`${file.name} の読み込みに失敗しました`);
            }
          }
          setSources(newSources);
          setPages(newPages);
        };

        const openEditor = async (page) => {
           const source = sources.get(page.sourcePdfId);
           if (!source) return;
           const { dataUrl, textContent, viewport } = await renderHighResPage(page, source);
           setEditingData({ imageSrc: dataUrl, textContent, viewportInfo: viewport });
           setEditingPageId(page.id);
        };

        const saveAnnotations = (newAnns) => {
           pushPageHistory();
           setPages(pages.map(p => p.id === editingPageId ? { ...p, annotations: newAnns } : p));
           setEditingPageId(null); setEditingData(null);
        };

        const deletePages = () => {
           if (selectedPageIds.size === 0) {
               if (viewMode === 'stack' || viewMode === 'carousel') {
                   // Delete current focused page
                   const target = pages[focusedPageIndex];
                   if (target && confirm("表示中のページを削除しますか？")) {
                       pushPageHistory();
                       setPages(prev => prev.filter(p => p.id !== target.id));
                       if (focusedPageIndex >= pages.length - 1) setFocusedPageIndex(Math.max(0, pages.length - 2));
                   }
               }
               return;
           }
           if (!confirm(`${selectedPageIds.size} ページを削除してもよろしいですか？`)) return;
           pushPageHistory();
           setPages(pages.filter(p => !selectedPageIds.has(p.id)));
           setSelectedPageIds(new Set());
        };

        const rotatePages = () => {
            pushPageHistory();
            if (selectedPageIds.size === 0) {
                 // Rotate focused page if none selected
                 if (viewMode === 'stack' || viewMode === 'carousel') {
                     const targetIndex = focusedPageIndex;
                     setPages(prev => prev.map((p, i) => i === targetIndex ? { ...p, rotation: (p.rotation + 90) % 360 } : p));
                 }
                 return;
            }
            setPages(prev => prev.map(p => selectedPageIds.has(p.id) ? { ...p, rotation: (p.rotation + 90) % 360 } : p));
        };

        const movePage = (fromIndex, toIndex) => {
             if (fromIndex === toIndex) return;
             pushPageHistory();
             const newPages = [...pages];
             const [moved] = newPages.splice(fromIndex, 1);
             newPages.splice(toIndex, 0, moved);
             setPages(newPages);
             setFocusedPageIndex(toIndex);
        };
        
        const moveGroup = (sourcePdfId, direction) => {
             const groupIndex = groupedPages.findIndex(g => g[0].sourcePdfId === sourcePdfId);
             if (groupIndex === -1) return;
             const targetIndex = groupIndex + direction;
             if (targetIndex < 0 || targetIndex >= groupedPages.length) return;
             
             pushPageHistory();
             const newGroups = [...groupedPages];
             const [moved] = newGroups.splice(groupIndex, 1);
             newGroups.splice(targetIndex, 0, moved);
             setPages(newGroups.flat());
        };

        const toggleSelection = (id, multi) => {
            const newSet = new Set(multi ? selectedPageIds : []);
            if (newSet.has(id)) newSet.delete(id); else newSet.add(id);
            setSelectedPageIds(newSet);
        };

        const selectAll = () => {
             if (selectedPageIds.size === pages.length) setSelectedPageIds(new Set());
             else setSelectedPageIds(new Set(pages.map(p => p.id)));
        };

        const applyPageNumbers = () => {
            pushPageHistory();
            // 1. Remove existing page numbers
            const cleanedPages = pages.map(p => ({
                ...p,
                annotations: (p.annotations || []).filter(a => !a.isPageNumber)
            }));
            
            // 2. Add new numbers if not reset
            const newPages = cleanedPages.map((p, i) => {
                 if (pageNumPosition === 'none') return p;
                 const text = `${i + 1}`;
                 const fontSize = 16;
                 const margin = 20;
                 let x = 0, y = 0;
                 // Calculate position based on original dimensions (unrotated)
                 // NOTE: For better placement, we should consider rotation, but simplified here to bottom of page
                 if (pageNumPosition === 'bottom-center') {
                     x = p.originalWidth / 2 - (text.length * fontSize / 4);
                     y = p.originalHeight - margin - fontSize;
                 } else { // bottom-right
                     x = p.originalWidth - margin - (text.length * fontSize / 2);
                     y = p.originalHeight - margin - fontSize;
                 }
                 
                 const ann = { 
                     id: generateId(), type: 'text', text, x, y, color: '#000000', fontSize, 
                     fontFamily: 'sans-serif', isPageNumber: true 
                 };
                 return { ...p, annotations: [...p.annotations, ann] };
            });
            setPages(newPages);
            setShowPageNumModal(false);
        };

        const handleSavePDF = async () => {
            if (pages.length === 0) return;
            const fileName = prompt("保存するファイル名を入力してください", "merged.pdf");
            if (!fileName) return;
            
            try {
               const pdfBytes = await generateFinalPDF(pages, sources);
               if (window.showSaveFilePicker) {
                   const handle = await window.showSaveFilePicker({ suggestedName: fileName, types: [{ description: 'PDF Files', accept: {'application/pdf': ['.pdf']} }] });
                   const writable = await handle.createWritable();
                   await writable.write(pdfBytes);
                   await writable.close();
               } else {
                   download(pdfBytes, fileName, "application/pdf");
               }
            } catch (e) {
               console.error(e);
               alert("PDFの保存に失敗しました");
            }
        };

        // Keyboard Navigation (Global)
        useEffect(() => {
           const handleKey = (e) => {
               if (editingPageId) return; // handled by editor
               if (e.target.tagName === 'INPUT') return;
               
               if (e.key === 'ArrowRight') setFocusedPageIndex(i => Math.min(pages.length - 1, i + 1));
               if (e.key === 'ArrowLeft') setFocusedPageIndex(i => Math.max(0, i - 1));
           };
           window.addEventListener('keydown', handleKey);
           return () => window.removeEventListener('keydown', handleKey);
        }, [pages, editingPageId]);
        
        // Carousel Scroll Effect
        useEffect(() => {
            if (viewMode === 'carousel' && carouselRef.current) {
                const target = carouselRef.current.children[focusedPageIndex];
                if (target) target.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
        }, [focusedPageIndex, viewMode]);

        // --- RENDER THUMBNAIL HELPER ---
        const renderThumbnailContent = (page) => {
            const isLandscape = page.rotation % 180 !== 0;
            const containerStyle = {
               width: '100%', height: '100%', position: 'relative', overflow: 'hidden',
               display: 'flex', alignItems: 'center', justifyContent: 'center'
            };
            // Render Annotations on thumbnail
            const renderMiniAnns = () => {
                return (page.annotations || []).map(ann => {
                    let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                    if (ann.type === 'arrow') { 
                       const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height); 
                       boxX = minX; boxY = minY; boxW = Math.abs(ann.width); boxH = Math.abs(ann.height);
                    } else if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                    
                    const style = {
                        position: 'absolute',
                        left: `${(boxX / page.originalWidth) * 100}%`, top: `${(boxY / page.originalHeight) * 100}%`,
                        width: boxW ? `${(boxW / page.originalWidth) * 100}%` : 'auto',
                        height: boxH ? `${(boxH / page.originalHeight) * 100}%` : 'auto',
                        color: ann.color, fontSize: `${(ann.fontSize/page.originalWidth)*100}cqw`, // relative font size
                        pointerEvents: 'none'
                    };
                    
                    if (ann.type === 'image') return <img key={ann.id} src={ann.imageData} style={{...style, objectFit:'contain'}} />;
                    if (ann.type === 'text') return <div key={ann.id} style={{...style, whiteSpace:'nowrap', fontSize: '10px'}}>{ann.text}</div>;
                    if (ann.type === 'rect') return <div key={ann.id} style={{...style, border: `2px solid ${ann.color}`}} />;
                    return null;
                });
            };

            return (
                 <div style={containerStyle}>
                     <div style={{ position: 'relative', width: isLandscape ? 'auto' : '100%', height: isLandscape ? '100%' : 'auto', aspectRatio: `${page.originalWidth}/${page.originalHeight}`, transform: `rotate(${page.rotation}deg)` }}>
                        <img src={page.thumbnailUrl} style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                        <div style={{ position: 'absolute', inset: 0, transform: `rotate(${-page.rotation}deg)`, width: '100%', height: '100%' }}>
                           {/* Simplified Annotation Overlay for Thumbnail */}
                           {renderMiniAnns()}
                        </div>
                     </div>
                 </div>
            );
        };

        // --- SUB VIEWS ---
        const renderGridView = () => (
             <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 p-4 pb-20">
                 {pages.map((page, i) => (
                    <div 
                       key={page.id} 
                       className={`relative group bg-white rounded-lg shadow-sm border-2 transition-all ${selectedPageIds.has(page.id) ? 'border-brand-500 ring-2 ring-brand-100' : 'border-gray-200 hover:border-brand-300'} ${focusedPageIndex === i ? 'ring-2 ring-brand-400' : ''}`}
                       onClick={(e) => { if (!e.shiftKey) toggleSelection(page.id, e.ctrlKey || e.metaKey); setFocusedPageIndex(i); }}
                       onDoubleClick={() => openEditor(page)}
                       draggable
                       onDragStart={(e) => { e.dataTransfer.setData('pageIndex', i); }}
                       onDragOver={(e) => { e.preventDefault(); }}
                       onDrop={(e) => { 
                           e.preventDefault(); const fromIdx = Number(e.dataTransfer.getData('pageIndex')); 
                           if (e.shiftKey) { /* Group Move Logic could be here */ } else movePage(fromIdx, i); 
                       }}
                    >
                        <div className="absolute top-2 left-2 z-10" onClick={(e) => e.stopPropagation()}>
                            <input type="checkbox" checked={selectedPageIds.has(page.id)} onChange={() => toggleSelection(page.id, true)} className="w-5 h-5 rounded border-gray-300 text-brand-600 focus:ring-brand-500" />
                        </div>
                        <div className="absolute top-2 right-2 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex space-x-1">
                             <button onClick={(e) => { e.stopPropagation(); const ids = groupedPages.find(g => g[0].sourcePdfId === page.sourcePdfId)?.map(p=>p.id); if (ids) setSelectedPageIds(prev => { const n = new Set(prev); const all = ids.every(id => n.has(id)); ids.forEach(id => all ? n.delete(id) : n.add(id)); return n; }); }} className="p-1 bg-white rounded shadow hover:bg-gray-100" title="このファイルのページを一括選択"><Folder size={14}/></button>
                             <button onClick={(e) => { e.stopPropagation(); openEditor(page); }} className="p-1 bg-white rounded shadow hover:bg-gray-100"><Edit3 size={14}/></button>
                        </div>
                        
                        <div className="aspect-[3/4] p-2 flex items-center justify-center bg-gray-50 rounded-t-lg overflow-hidden">
                             {renderThumbnailContent(page)}
                        </div>
                        <div className="bg-gray-50 px-2 py-1 text-center text-xs text-gray-500 border-t rounded-b-lg">
                             {i + 1}
                        </div>
                        
                        {/* Drag Indicator (Blue Line) */}
                        {/* CSS handles drag-over visual via classes usually, simplified here */}
                    </div>
                 ))}
             </div>
        );

        const renderStackView = () => (
             <div className="flex-1 relative flex items-center justify-center overflow-hidden bg-gray-200 p-8 perspective-[1000px]">
                 {pages.map((page, i) => {
                     const offset = i - focusedPageIndex;
                     const absOffset = Math.abs(offset);
                     if (absOffset > 5) return null; // Don't render too far
                     const zIndex = 100 - absOffset;
                     const scale = Math.max(0.8, 1 - absOffset * 0.05);
                     const translateX = offset * 40; // Dense stack
                     const translateZ = -absOffset * 50;
                     const opacity = Math.max(0, 1 - absOffset * 0.2);
                     
                     return (
                         <div 
                             key={page.id}
                             className={`absolute top-1/2 left-1/2 w-[400px] max-w-[90vw] aspect-[1/1.414] bg-white shadow-2xl border transition-all duration-500 ease-out cursor-pointer`}
                             style={{ 
                                 zIndex, opacity,
                                 transform: `translate(-50%, -50%) translate3d(${translateX}px, 0, ${translateZ}px) scale(${scale})`
                             }}
                             onClick={() => setFocusedPageIndex(i)}
                             onDoubleClick={() => i === focusedPageIndex && openEditor(page)}
                         >
                             {renderThumbnailContent(page)}
                             {i === focusedPageIndex && (
                                 <div className="absolute bottom-4 left-0 right-0 flex justify-center space-x-4">
                                     <button onClick={() => openEditor(page)} className="bg-brand-600 text-white px-4 py-1 rounded shadow hover:bg-brand-700">編集</button>
                                 </div>
                             )}
                         </div>
                     );
                 })}
             </div>
        );

        const renderCarouselView = () => (
             <div className="flex-1 flex flex-col bg-gray-900 overflow-hidden">
                  <div ref={carouselRef} className="flex-1 flex items-center space-x-8 px-[50vw] overflow-x-auto scrollbar-hide py-8">
                      {pages.map((page, i) => (
                          <div 
                              key={page.id}
                              className={`flex-shrink-0 relative transition-all duration-300 ${i === focusedPageIndex ? 'scale-100 opacity-100 z-10' : 'scale-90 opacity-50'}`}
                              style={{ height: '80vh', width: 'auto', aspectRatio: `${page.originalWidth}/${page.originalHeight}` }}
                              onClick={() => setFocusedPageIndex(i)}
                              onDoubleClick={() => openEditor(page)}
                          >
                              <div className="w-full h-full bg-white shadow-lg">
                                  {renderThumbnailContent(page)}
                              </div>
                              <div className="absolute bottom-2 left-0 right-0 text-center text-white bg-black/50 text-sm py-1 rounded-b">
                                  {i + 1}
                              </div>
                          </div>
                      ))}
                  </div>
                  {/* Carousel Controls */}
                  <div className="h-16 bg-gray-800 flex items-center justify-center space-x-8 text-white">
                       <button onClick={() => setFocusedPageIndex(i => Math.max(0, i-1))}><ChevronLeft size={24}/></button>
                       <span className="font-mono text-xl">{focusedPageIndex + 1} / {pages.length}</span>
                       <button onClick={() => setFocusedPageIndex(i => Math.min(pages.length-1, i+1))}><ChevronRight size={24}/></button>
                       
                       <div className="w-px h-8 bg-gray-600 mx-4"></div>
                       <button onClick={rotatePages} title="回転"><RotateCw size={20}/></button>
                       <button onClick={deletePages} title="削除" className="text-red-400"><Trash2 size={20}/></button>
                       <button onClick={() => openEditor(pages[focusedPageIndex])} title="編集" className="text-brand-400"><Edit3 size={20}/></button>
                  </div>
             </div>
        );

        const renderFolderView = () => (
             <div className="p-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                 {groupedPages.map((group, gIdx) => (
                     <div key={gIdx} className="bg-white rounded-xl shadow p-4 border relative group" draggable onDragStart={(e) => e.dataTransfer.setData('groupIdx', gIdx)} onDrop={(e) => { const f = e.dataTransfer.getData('groupIdx'); if (f) moveGroup(group[0].sourcePdfId, Number(f) < gIdx ? -1 : 1); }}>
                         <div className="flex items-center justify-between mb-2">
                             <h3 className="font-bold text-gray-700 truncate max-w-[200px]">FILE {gIdx + 1}</h3>
                             <span className="text-xs text-gray-500">{group.length} ページ</span>
                         </div>
                         <div className="h-40 relative bg-gray-100 rounded border overflow-hidden flex items-center justify-center">
                              {/* Stack visual */}
                              {group.slice(0,3).map((p, k) => (
                                  <div key={k} className="absolute bg-white shadow border w-24 h-32" style={{ left: 50 + k*10 + '%', top: 50 + k*5 + '%', transform: 'translate(-50%, -50%)', zIndex: k }}>
                                      <img src={p.thumbnailUrl} className="w-full h-full object-contain opacity-80" />
                                  </div>
                              ))}
                         </div>
                         <div className="mt-2 flex justify-end space-x-2">
                             <button onClick={() => { setSelectedPageIds(prev => { const n = new Set(prev); group.forEach(p => n.add(p.id)); return n; }); }} className="text-sm text-brand-600 hover:underline">全選択</button>
                         </div>
                     </div>
                 ))}
             </div>
        );

        // --- MAIN RENDER ---
        if (editingData && editingPageId) {
           const page = pages.find(p => p.id === editingPageId);
           return <AnnotationEditor page={page} {...editingData} onClose={() => { setEditingPageId(null); setEditingData(null); }} onSave={saveAnnotations} />;
        }

        return (
          <div className="h-screen flex flex-col bg-gray-50 font-sans text-slate-800">
             {/* Header */}
             <header className="bg-white border-b h-16 flex items-center justify-between px-6 shadow-sm z-40">
                <div className="flex items-center space-x-4">
                    <div className="bg-brand-600 text-white p-2 rounded-lg"><Shapes size={24} /></div>
                    <h1 className="text-xl font-bold text-gray-800 hidden md:block">PDF Master Studio</h1>
                </div>
                
                <div className="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                    <button onClick={() => setViewMode('grid')} className={`p-2 rounded ${viewMode === 'grid' ? 'bg-white shadow text-brand-600' : 'text-gray-500'}`} title="グリッド表示"><LayoutGrid size={20}/></button>
                    <button onClick={() => setViewMode('stack')} className={`p-2 rounded ${viewMode === 'stack' ? 'bg-white shadow text-brand-600' : 'text-gray-500'}`} title="スタック表示"><Layers size={20}/></button>
                    <button onClick={() => setViewMode('carousel')} className={`p-2 rounded ${viewMode === 'carousel' ? 'bg-white shadow text-brand-600' : 'text-gray-500'}`} title="カルーセル表示"><Columns size={20}/></button>
                    <button onClick={() => setViewMode('folder')} className={`p-2 rounded ${viewMode === 'folder' ? 'bg-white shadow text-brand-600' : 'text-gray-500'}`} title="フォルダ表示"><Folder size={20}/></button>
                </div>

                <div className="flex items-center space-x-3">
                    <button onClick={undoPages} disabled={pageHistory.length === 0} className={`p-2 rounded flex items-center ${pageHistory.length===0 ? 'text-gray-300' : 'hover:bg-gray-100'}`} title="元に戻す"><Undo size={20} className="mr-1"/> <span className="text-sm hidden sm:inline">戻す</span></button>
                    <button onClick={() => setShowPageNumModal(true)} className="flex items-center space-x-1 px-3 py-2 hover:bg-gray-100 rounded text-gray-700 text-sm bg-gray-50 border"><Hash size={16}/> <span>ページ番号</span></button>
                    <button onClick={() => fileInputRef.current?.click()} className="flex items-center space-x-2 bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded hover:bg-gray-50 transition"><Plus size={18}/> <span>ファイル追加</span></button>
                    <button onClick={handleSavePDF} disabled={pages.length === 0} className={`flex items-center space-x-2 px-5 py-2 rounded font-bold transition shadow-sm ${pages.length===0 ? 'bg-gray-300 text-white cursor-not-allowed' : 'bg-brand-600 text-white hover:bg-brand-700'}`}><FileDown size={20}/> <span>PDF保存</span></button>
                </div>
             </header>

             {/* Main Content */}
             <main className="flex-1 overflow-auto relative" 
                  onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); }} 
                  onDrop={(e) => { e.preventDefault(); handleFileUpload(e); }}
                  onClick={(e) => { if (pages.length === 0) fileInputRef.current?.click(); }}
             >
                {pages.length === 0 ? (
                   <div className="h-full flex flex-col items-center justify-center text-gray-400 space-y-4 cursor-pointer hover:bg-gray-100/50 transition">
                       <div className="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mb-4">
                          <Upload size={48} className="text-gray-400" />
                       </div>
                       <p className="text-xl font-bold text-gray-500">ここにPDFをドロップ または クリックして選択</p>
                       <p className="text-sm">JPG, PNG 画像もサポートしています</p>
                   </div>
                ) : (
                   <>
                     {viewMode === 'grid' && renderGridView()}
                     {viewMode === 'stack' && renderStackView()}
                     {viewMode === 'carousel' && renderCarouselView()}
                     {viewMode === 'folder' && renderFolderView()}
                   </>
                )}
             </main>

             {/* Footer Controls (Grid/Folder Only) */}
             {(viewMode === 'grid' || viewMode === 'folder') && pages.length > 0 && (
                <div className="h-14 bg-white border-t flex items-center justify-between px-6 z-40">
                    <div className="flex items-center space-x-4 text-sm text-gray-500">
                        <label className="flex items-center space-x-2 cursor-pointer select-none">
                            <input type="checkbox" checked={selectedPageIds.size > 0 && selectedPageIds.size === pages.length} onChange={selectAll} ref={el => { if (el) el.indeterminate = selectedPageIds.size > 0 && selectedPageIds.size < pages.length; }} className="w-4 h-4 text-brand-600 rounded border-gray-300 focus:ring-brand-500"/>
                            <span>{selectedPageIds.size} ページ選択中</span>
                        </label>
                    </div>
                    <div className="flex items-center space-x-2">
                        <button onClick={rotatePages} className="flex items-center px-3 py-1.5 hover:bg-gray-100 rounded text-gray-700 disabled:opacity-50" disabled={pages.length === 0}><RotateCw size={18} className="mr-2"/> 回転</button>
                        <button onClick={deletePages} className="flex items-center px-3 py-1.5 hover:bg-red-50 text-red-600 rounded disabled:opacity-50" disabled={selectedPageIds.size === 0 && viewMode === 'grid'}><Trash2 size={18} className="mr-2"/> 削除</button>
                    </div>
                </div>
             )}

             {/* Modals */}
             {showPageNumModal && (
                 <div className="fixed inset-0 bg-black/50 z-[70] flex items-center justify-center p-4">
                     <div className="bg-white rounded-lg shadow-xl w-full max-w-md p-6 animate-bounce-in">
                         <h3 className="text-lg font-bold mb-4">ページ番号を追加</h3>
                         <div className="space-y-3 mb-6">
                             <label className="flex items-center space-x-3 p-3 border rounded cursor-pointer hover:bg-gray-50">
                                 <input type="radio" name="pageNum" checked={pageNumPosition === 'bottom-center'} onChange={() => setPageNumPosition('bottom-center')} className="text-brand-600"/>
                                 <span>中央下 (フッター)</span>
                             </label>
                             <label className="flex items-center space-x-3 p-3 border rounded cursor-pointer hover:bg-gray-50">
                                 <input type="radio" name="pageNum" checked={pageNumPosition === 'bottom-right'} onChange={() => setPageNumPosition('bottom-right')} className="text-brand-600"/>
                                 <span>右下</span>
                             </label>
                             <label className="flex items-center space-x-3 p-3 border rounded cursor-pointer hover:bg-gray-50">
                                 <input type="radio" name="pageNum" checked={pageNumPosition === 'none'} onChange={() => setPageNumPosition('none')} className="text-brand-600"/>
                                 <span>なし (削除)</span>
                             </label>
                         </div>
                         <div className="flex justify-end space-x-2">
                             <button onClick={() => setShowPageNumModal(false)} className="px-4 py-2 hover:bg-gray-100 rounded">キャンセル</button>
                             <button onClick={applyPageNumbers} className="px-4 py-2 bg-brand-600 text-white rounded hover:bg-brand-700">適用</button>
                         </div>
                     </div>
                 </div>
             )}

             <input type="file" ref={fileInputRef} multiple accept="application/pdf,image/*" className="hidden" onChange={handleFileUpload} />
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>