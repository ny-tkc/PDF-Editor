<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Master Studio</title>
    <meta name="description" content="高度なPDF編集ツール。結合、ページ削除、回転、注釈（テキスト、赤枠、矢印）の追加が可能。日本語UI対応。" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
              }
            }
          }
        }
      }
    </script>

    <!-- React & ReactDOM (Crossorigin for error reporting) -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX/TS -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF Libraries -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>

    <style>
      /* Custom scrollbar for better UI */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f5f9; 
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; 
      }
    </style>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-100 text-slate-800">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- ICONS (Inlined to prevent loading errors) ---
      const createIcon = (path) => (props) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={props.size || 24} 
          height={props.size || 24} 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth={props.strokeWidth || 2} 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={props.className}
          {...props}
        >
          {path}
        </svg>
      );

      const Icons = {
        X: createIcon(<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>),
        Square: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        ArrowRight: createIcon(<><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></>),
        Type: createIcon(<><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></>),
        Move: createIcon(<><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></>),
        Check: createIcon(<polyline points="20 6 9 17 4 12"></polyline>),
        Highlighter: createIcon(<><path d="m9 11-6 6v3h9l2-2"></path><path d="m22 7-8.1 8.1"></path><path d="M16 3 2.6 16.4"></path></>),
        ImageIcon: createIcon(<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></>),
        ZoomIn: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        ZoomOut: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        Maximize: createIcon(<><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></>),
        Bold: createIcon(<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>),
        Upload: createIcon(<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></>),
        FileDown: createIcon(<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18v-6"></path><path d="m9 15 3 3 3-3"></path></>),
        Trash2: createIcon(<><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>),
        RotateCw: createIcon(<path d="M23 4v6h-6 M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>),
        Edit3: createIcon(<path d="M12 20h9 M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>),
        Copy: createIcon(<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></>),
        Plus: createIcon(<><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>),
      };
      
      const { 
        X, Square, ArrowRight, Type, Move, Check, Highlighter, 
        ImageIcon, ZoomIn, ZoomOut, Maximize, Bold, 
        Upload, FileDown, Trash2, RotateCw, Edit3, Copy, Plus 
      } = Icons;

      // Safe UUID generator that works in non-secure contexts
      const generateId = () => {
        if (typeof crypto !== 'undefined' && crypto.randomUUID && window.isSecureContext) {
          return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      };

      // --- CONFIG ---
      if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }

      // --- UTILS ---
      
      const loadPDF = async (file) => {
        let arrayBuffer = await file.arrayBuffer();
        let fileName = file.name;

        // Check if the file is an image and convert to PDF if so
        const isImage = file.type.startsWith('image/') || /\.(jpg|jpeg|png|webp)$/i.test(file.name);

        if (isImage && file.type !== 'application/pdf') {
          try {
            const pdfDoc = await PDFLib.PDFDocument.create();
            let image;
            
            // Try to embed based on type or fallback
            if (file.type === 'image/jpeg' || file.type === 'image/jpg' || fileName.toLowerCase().endsWith('.jpg') || fileName.toLowerCase().endsWith('.jpeg')) {
              image = await pdfDoc.embedJpg(arrayBuffer);
            } else {
              // Try PNG, fallback to JPG if that fails
              try {
                 image = await pdfDoc.embedPng(arrayBuffer);
              } catch (e) {
                 image = await pdfDoc.embedJpg(arrayBuffer);
              }
            }

            const page = pdfDoc.addPage([image.width, image.height]);
            page.drawImage(image, {
              x: 0,
              y: 0,
              width: image.width,
              height: image.height,
            });

            const pdfBytes = await pdfDoc.save();
            arrayBuffer = pdfBytes.buffer;
            fileName = fileName + ".pdf"; 
          } catch (e) {
            console.error("Image to PDF conversion failed", e);
            throw new Error("Unsupported image format. Please use PDF, JPG, or PNG.");
          }
        }

        // Load the PDF
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer.slice(0) });
        const pdf = await loadingTask.promise;
        
        const sourceId = generateId();
        const pages = [];

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const viewport = page.getViewport({ scale: 0.5 }); // Thumbnail scale
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({ canvasContext: context, viewport: viewport }).promise;

          pages.push({
            id: generateId(),
            sourcePdfId: sourceId,
            pageIndex: i,
            rotation: 0,
            thumbnailUrl: canvas.toDataURL(),
            originalWidth: viewport.width * 2, 
            originalHeight: viewport.height * 2,
            annotations: []
          });
        }

        return {
          source: {
            id: sourceId,
            name: fileName,
            data: arrayBuffer
          },
          pages
        };
      };

      const generateFinalPDF = async (pages, sources) => {
        const mergedPdf = await PDFLib.PDFDocument.create();

        for (const pageData of pages) {
          const source = sources.get(pageData.sourcePdfId);
          if (!source) continue;

          // Load source doc
          const sourcePdfDoc = await PDFLib.PDFDocument.load(source.data);
          
          // Copy page
          const [copiedPage] = await mergedPdf.copyPages(sourcePdfDoc, [pageData.pageIndex]);
          
          // Apply Rotation
          const currentRotation = copiedPage.getRotation().angle;
          copiedPage.setRotation(PDFLib.degrees(currentRotation + pageData.rotation));

          // Embed Annotations
          if (pageData.annotations.length > 0) {
            const canvas = document.createElement('canvas');
            const width = pageData.originalWidth;
            const height = pageData.originalHeight;
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (ctx) {
              ctx.textBaseline = 'top'; 

              for (const ann of pageData.annotations) {
                 ctx.globalAlpha = 1.0; 
                 
                 let boxX = ann.x || 0;
                 let boxY = ann.y || 0;
                 let boxW = ann.width || 0;
                 let boxH = ann.height || 0;
                 
                 if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
                 if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }

                 if (ann.type === 'highlight') {
                     ctx.fillStyle = ann.color;
                     ctx.globalAlpha = 0.4;
                     ctx.fillRect(boxX, boxY, boxW, boxH);
                     ctx.globalAlpha = 1.0; 
                 } else if (ann.type === 'rect') {
                   ctx.strokeStyle = ann.color;
                   ctx.fillStyle = ann.color;
                   ctx.lineWidth = 4;
                   ctx.strokeRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 32;
                   ctx.font = `${fontWeight} ${fSize}px sans-serif`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 } else if (ann.type === 'arrow') {
                   ctx.strokeStyle = ann.color;
                   ctx.fillStyle = ann.color;
                   ctx.lineWidth = 5;
                   
                   const fromX = ann.x;
                   const fromY = ann.y;
                   const toX = (ann.x + (ann.width || 0));
                   const toY = (ann.y + (ann.height || 0));
                   
                   const headLen = 20; 
                   const angle = Math.atan2(toY - fromY, toX - fromX);
                   
                   ctx.beginPath();
                   ctx.moveTo(fromX, fromY);
                   ctx.lineTo(toX, toY);
                   ctx.stroke();
                   
                   ctx.beginPath();
                   ctx.moveTo(toX, toY);
                   ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
                   ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
                   ctx.closePath();
                   ctx.fill();
                 } else if (ann.type === 'image' && ann.imageData) {
                     await new Promise((resolve) => {
                         const img = new Image();
                         img.onload = () => {
                             ctx.drawImage(img, boxX, boxY, boxW, boxH);
                             resolve(null);
                         };
                         img.src = ann.imageData; 
                     });
                 }
              }

              const pngImageBytes = await fetch(canvas.toDataURL('image/png')).then(res => res.arrayBuffer());
              const pngImage = await mergedPdf.embedPng(pngImageBytes);
              
              copiedPage.drawImage(pngImage, {
                x: 0,
                y: 0,
                width: copiedPage.getWidth(),
                height: copiedPage.getHeight(),
              });
            }
          }

          mergedPdf.addPage(copiedPage);
        }

        return await mergedPdf.save();
      };

      const renderHighResPage = async (pageData, source) => {
          const loadingTask = pdfjsLib.getDocument({ data: source.data.slice(0) });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(pageData.pageIndex + 1);
          
          const viewport = page.getViewport({ scale: 1.5, rotation: pageData.rotation });
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({ canvasContext: context, viewport: viewport }).promise;
          return canvas.toDataURL();
      };

      // --- COMPONENTS ---

      // Removed generics and 'React.FC' to avoid parsing errors
      const AnnotationEditor = ({ page, imageSrc, onClose, onSave }) => {
        const [annotations, setAnnotations] = useState(page.annotations || []);
        const [tool, setTool] = useState('select');
        
        // Tool settings
        const [color, setColor] = useState('#ef4444');
        const [fontSize, setFontSize] = useState(32);
        const [isBold, setIsBold] = useState(false);
        const [zoom, setZoom] = useState(0.8);
        
        // Interaction state
        const [isDrawing, setIsDrawing] = useState(false);
        const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 }); 
        const [currentAnnotation, setCurrentAnnotation] = useState(null); 
        
        // Selection / Move / Resize state
        const [selectedId, setSelectedId] = useState(null);
        const [interactionMode, setInteractionMode] = useState('none');
        const [resizeHandle, setResizeHandle] = useState(null);
        const [interactionStartPos, setInteractionStartPos] = useState({ x: 0, y: 0 });
        const [initialAnnState, setInitialAnnState] = useState(null);
        
        const imgRef = useRef(null);
        const containerRef = useRef(null);
        const fileInputRef = useRef(null);

        // Initialize zoom
        useEffect(() => {
           if (containerRef.current) {
              const viewportHeight = window.innerHeight - 140;
              const initialZoom = Math.min(0.9, viewportHeight / page.originalHeight);
              setZoom(initialZoom);
           }
        }, [page.originalHeight]);

        // Sync toolbar changes to SELECTED annotation
        useEffect(() => {
          if (selectedId) {
              setAnnotations(prev => prev.map(ann => {
                  if (ann.id === selectedId) {
                      const updates = {};
                      if (ann.type === 'text') {
                          updates.fontSize = fontSize;
                          updates.fontWeight = isBold ? 'bold' : 'normal';
                      }
                      return { ...ann, ...updates };
                  }
                  return ann;
              }));
          }
        }, [fontSize, isBold, selectedId]);

        const applyColor = (newColor) => {
            setColor(newColor);
            if (selectedId) {
                setAnnotations(prev => prev.map(ann => {
                    if (ann.id === selectedId) {
                        return { ...ann, color: newColor };
                    }
                    return ann;
                }));
            }
        };

        const getPointerPos = (e) => {
          if (!imgRef.current) return { x: 0, y: 0 };
          const rect = imgRef.current.getBoundingClientRect();
          const relX = e.clientX - rect.left;
          const relY = e.clientY - rect.top;
          
          const scaleX = page.originalWidth / rect.width;
          const scaleY = page.originalHeight / rect.height;
          
          return {
            x: relX * scaleX,
            y: relY * scaleY
          };
        };

        const handleMouseDown = (e) => {
          if (interactionMode === 'resizing') return;
          if (interactionMode === 'moving') return;

          if (tool === 'select') {
              setSelectedId(null); 
              return;
          }
          
          e.preventDefault();
          const { x, y } = getPointerPos(e);
          setDragStartPos({ x, y });
          setIsDrawing(true);

          if (tool === 'text') {
             const text = prompt("テキストを入力してください:", "");
             if (text && text.trim() !== "") {
               const newAnn = {
                 id: generateId(),
                 type: 'text',
                 x,
                 y,
                 text,
                 color,
                 fontSize: fontSize,
                 fontWeight: isBold ? 'bold' : 'normal',
               };
               setAnnotations([...annotations, newAnn]);
               setSelectedId(newAnn.id); 
             }
             setIsDrawing(false);
          } else if (tool === 'image') {
              fileInputRef.current?.click();
              setIsDrawing(false);
          } else {
            const shapeColor = tool === 'highlight' ? '#ffff00' : color;
            setCurrentAnnotation({
              type: tool,
              x,
              y,
              width: 0,
              height: 0,
              color: shapeColor
            });
          }
        };

        const handleMouseMove = (e) => {
          const { x, y } = getPointerPos(e);

          if (interactionMode === 'moving' && selectedId && initialAnnState) {
              const dx = x - interactionStartPos.x;
              const dy = y - interactionStartPos.y;

              setAnnotations(prev => prev.map(ann => {
                  if (ann.id === selectedId) {
                      return { ...ann, x: initialAnnState.x + dx, y: initialAnnState.y + dy };
                  }
                  return ann;
              }));
              return;
          }

          if (interactionMode === 'resizing' && selectedId && initialAnnState && resizeHandle) {
              const dx = x - interactionStartPos.x;
              const dy = y - interactionStartPos.y;

              setAnnotations(prev => prev.map(ann => {
                  if (ann.id !== selectedId) return ann;

                  let newX = initialAnnState.x;
                  let newY = initialAnnState.y;
                  let newW = initialAnnState.width || 0;
                  let newH = initialAnnState.height || 0;

                  if (resizeHandle.includes('e')) newW += dx;
                  if (resizeHandle.includes('w')) { newX += dx; newW -= dx; }
                  if (resizeHandle.includes('s')) newH += dy;
                  if (resizeHandle.includes('n')) { newY += dy; newH -= dy; }

                  return { ...ann, x: newX, y: newY, width: newW, height: newH };
              }));
              return;
          }

          if (!isDrawing || !currentAnnotation || tool === 'text' || tool === 'image') return;
          
          setCurrentAnnotation(prev => ({
            ...prev,
            width: x - dragStartPos.x,
            height: y - dragStartPos.y
          }));
        };

        const handleMouseUp = () => {
          setInteractionMode('none');
          setResizeHandle(null);
          setInitialAnnState(null);

          if (!isDrawing) return;
          setIsDrawing(false);
          
          if (currentAnnotation && (Math.abs(currentAnnotation.width || 0) > 5 || Math.abs(currentAnnotation.height || 0) > 5)) {
             const newAnn = {
               id: generateId(),
               type: currentAnnotation.type,
               x: dragStartPos.x,
               y: dragStartPos.y,
               width: currentAnnotation.width,
               height: currentAnnotation.height,
               color: currentAnnotation.color || color,
             };
             setAnnotations([...annotations, newAnn]);
             setSelectedId(newAnn.id);
          }
          setCurrentAnnotation(null);
        };

        const handleAnnotationMouseDown = (e, id) => {
            e.stopPropagation(); 
            if (tool !== 'select') return;

            const ann = annotations.find(a => a.id === id);
            if (!ann) return;

            setSelectedId(id);
            setInteractionMode('moving');
            setInteractionStartPos(getPointerPos(e));
            setInitialAnnState({ ...ann });
            
            if (ann.type === 'text') {
                setFontSize(ann.fontSize || 32);
                setIsBold(ann.fontWeight === 'bold');
            }
            if (ann.type !== 'highlight') {
                setColor(ann.color);
            }
        };

        const handleResizeStart = (e, handle, id) => {
            e.stopPropagation();
            e.preventDefault();
            
            const ann = annotations.find(a => a.id === id);
            if (!ann) return;

            setSelectedId(id);
            setInteractionMode('resizing');
            setResizeHandle(handle);
            setInteractionStartPos(getPointerPos(e));
            setInitialAnnState({ ...ann });
        };

        const handleImageUpload = (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                if (event.target?.result) {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.height / img.width;
                        const width = 300; 
                        const height = 300 * aspectRatio;
                        
                        const newAnn = {
                            id: generateId(),
                            type: 'image',
                            x: 100, 
                            y: 100,
                            width,
                            height,
                            color: '', 
                            imageData: event.target.result // removed 'as string'
                        };
                        setAnnotations([...annotations, newAnn]);
                        setSelectedId(newAnn.id);
                        setTool('select'); 
                    };
                    img.src = event.target.result; // removed 'as string'
                }
            };
            reader.readAsDataURL(file);
            e.target.value = ''; 
        };

        const deleteAnnotation = (id) => {
          setAnnotations(annotations.filter(a => a.id !== id));
          if (selectedId === id) setSelectedId(null);
        };

        const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); };
        const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); };

        const renderAnnotation = (ann, isPreview = false) => {
           const isSelected = !isPreview && ann.id === selectedId;

           let boxX = ann.x || 0;
           let boxY = ann.y || 0;
           let boxW = ann.width || 0;
           let boxH = ann.height || 0;

           if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
           if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }

           if (ann.type === 'text') {
               boxW = undefined; 
               boxH = undefined;
           }

           const style = {
             position: 'absolute',
             left: `${(boxX / page.originalWidth) * 100}%`,
             top: `${(boxY / page.originalHeight) * 100}%`,
             width: boxW !== undefined ? `${(boxW / page.originalWidth) * 100}%` : 'auto',
             height: boxH !== undefined ? `${(boxH / page.originalHeight) * 100}%` : 'auto',
             
             pointerEvents: tool === 'select' && !isPreview ? 'auto' : 'none',
             cursor: tool === 'select' ? 'move' : 'crosshair',
             userSelect: 'none',
             zIndex: isPreview ? 20 : (isSelected ? 30 : 10),
             
             outline: isSelected ? '2px dashed #0ea5e9' : 'none',
             outlineOffset: '2px',
           };

           const renderHandles = () => {
               if (!isSelected || ann.type === 'text') return null; 
               if (!ann.id) return null;
               const handleStyle = "absolute w-3 h-3 bg-white border border-brand-500 rounded-full z-50 pointer-events-auto";
               return (
                   <React.Fragment>
                      <div className={`${handleStyle} -top-1.5 -left-1.5 cursor-nw-resize`} onMouseDown={(e) => ann.id && handleResizeStart(e, 'nw', ann.id)} />
                      <div className={`${handleStyle} -top-1.5 -right-1.5 cursor-ne-resize`} onMouseDown={(e) => ann.id && handleResizeStart(e, 'ne', ann.id)} />
                      <div className={`${handleStyle} -bottom-1.5 -left-1.5 cursor-sw-resize`} onMouseDown={(e) => ann.id && handleResizeStart(e, 'sw', ann.id)} />
                      <div className={`${handleStyle} -bottom-1.5 -right-1.5 cursor-se-resize`} onMouseDown={(e) => ann.id && handleResizeStart(e, 'se', ann.id)} />
                   </React.Fragment>
               );
           }

           const renderContent = () => {
              if (ann.type === 'arrow') {
                   const rawX = ann.x || 0;
                   const rawY = ann.y || 0;
                   const rawW = ann.width || 0;
                   const rawH = ann.height || 0;
                   
                   const x1 = rawX - boxX;
                   const y1 = rawY - boxY;
                   const x2 = (rawX + rawW) - boxX;
                   const y2 = (rawY + rawH) - boxY;

                   const headLen = 20 * (1/zoom * 0.5 + 0.5);
                   const angle = Math.atan2(y2 - y1, x2 - x1);
                   const ax1 = x2 - headLen * Math.cos(angle - Math.PI / 6);
                   const ay1 = y2 - headLen * Math.sin(angle - Math.PI / 6);
                   const ax2 = x2 - headLen * Math.cos(angle + Math.PI / 6);
                   const ay2 = y2 - headLen * Math.sin(angle + Math.PI / 6);

                   return (
                       <svg width="100%" height="100%" style={{ overflow: 'visible', pointerEvents: 'none' }}>
                           <line x1={x1} y1={y1} x2={x2} y2={y2} stroke="transparent" strokeWidth="20" style={{ pointerEvents: 'stroke' }} />
                           <line x1={x1} y1={y1} x2={x2} y2={y2} stroke={ann.color} strokeWidth="5" />
                           <polygon points={`${x2},${y2} ${ax1},${ay1} ${ax2},${ay2}`} fill={ann.color} />
                       </svg>
                   );
               }
               if (ann.type === 'text') {
                   return (
                       <div style={{ 
                           color: ann.color, 
                           fontSize: `${(ann.fontSize || 32) * zoom}px`, 
                           fontWeight: ann.fontWeight || 'normal',
                           whiteSpace: 'nowrap',
                           textShadow: '0px 0px 3px white', 
                           padding: '4px',
                           lineHeight: 1
                       }}>
                          {ann.text}
                       </div>
                   );
               }
               if (ann.type === 'image' && ann.imageData) {
                   return <img src={ann.imageData} alt="img" draggable={false} className="w-full h-full object-contain select-none" />;
               }
               if (ann.type === 'highlight') {
                   return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color, opacity: 0.3 }} />;
               }
               if (ann.type === 'rect') {
                   return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}` }} />;
               }
               return null;
           }

           return (
              <div 
                  key={ann.id || 'preview'} 
                  style={style}
                  onMouseDown={(e) => ann.id && handleAnnotationMouseDown(e, ann.id)}
              >
                  {renderContent()}
                  {renderHandles()}
                  
                  {isSelected && (
                      <button 
                          onClick={(e) => { e.stopPropagation(); if (ann.id) deleteAnnotation(ann.id); }} 
                          className="absolute -top-3 -right-3 bg-red-500 text-white rounded-full p-1.5 shadow-md hover:bg-red-600 z-50 transform hover:scale-110 transition-transform flex items-center justify-center"
                          title="削除"
                      >
                           <X size={12} />
                      </button>
                  )}
              </div>
           );
        };

        return (
          <div 
              className="fixed inset-0 bg-slate-900 z-50 flex flex-col"
              onDragOver={handleDragOver} 
              onDrop={handleDrop}
          >
            <div className="bg-white p-3 flex justify-between items-center shadow-md z-20">
              <h2 className="text-lg font-bold flex items-center gap-2 text-slate-700">
                  <Move className="text-brand-600" size={20}/> ページ編集
              </h2>
              
              <div className="flex items-center gap-4">
                   <div className={`flex items-center gap-2 border-r border-slate-300 pr-4 transition-opacity ${tool === 'text' || (selectedId && annotations.find(a => a.id === selectedId)?.type === 'text') ? 'opacity-100' : 'opacity-30 pointer-events-none'}`}>
                       <Type size={16} className="text-slate-500" />
                       <input 
                          type="number" 
                          value={fontSize} 
                          onChange={(e) => setFontSize(Number(e.target.value))} 
                          className="w-16 border border-slate-300 rounded px-1 py-0.5 text-sm"
                          title="フォントサイズ"
                       />
                       <button 
                          onClick={() => setIsBold(!isBold)} 
                          className={`p-1 rounded ${isBold ? 'bg-brand-100 text-brand-600 border border-brand-200' : 'text-slate-500 hover:bg-slate-100'}`}
                          title="太字"
                       >
                           <Bold size={16} />
                       </button>
                   </div>

                   <div className="flex items-center gap-1 bg-slate-100 rounded-lg p-1">
                       <button onClick={() => setZoom(Math.max(0.2, zoom - 0.1))} className="p-1 hover:bg-white rounded text-slate-600"><ZoomOut size={16}/></button>
                       <span className="text-xs w-10 text-center font-mono">{Math.round(zoom * 100)}%</span>
                       <button onClick={() => setZoom(Math.min(3.0, zoom + 0.1))} className="p-1 hover:bg-white rounded text-slate-600"><ZoomIn size={16}/></button>
                       <button onClick={() => setZoom(0.8)} className="p-1 hover:bg-white rounded text-slate-600 ml-1" title="画面に合わせる"><Maximize size={16}/></button>
                   </div>

                   <div className="flex gap-2 ml-4">
                      <button onClick={onClose} className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded text-sm font-medium">キャンセル</button>
                      <button onClick={() => onSave(annotations)} className="px-6 py-2 bg-brand-600 text-white rounded shadow-sm hover:bg-brand-700 hover:shadow-md flex items-center gap-2 text-sm font-bold transition-all">
                          <Check size={18} /> 完了
                      </button>
                  </div>
              </div>
            </div>

            <div className="flex flex-1 overflow-hidden">
              <div className="w-16 bg-slate-800 flex flex-col items-center py-4 gap-3 z-20 shadow-xl overflow-y-auto">
                  <input type="file" ref={fileInputRef} className="hidden" accept="image/*" onChange={handleImageUpload} />
                  
                  <ToolButton active={tool === 'select'} onClick={() => setTool('select')} icon={<Move size={20} />} label="移動/選択" />
                  <div className="w-10 h-px bg-slate-600 my-1"></div>
                  <ToolButton active={tool === 'highlight'} onClick={() => setTool('highlight')} icon={<Highlighter size={20} />} label="蛍光ペン" />
                  <ToolButton active={tool === 'text'} onClick={() => setTool('text')} icon={<Type size={20} />} label="テキスト" />
                  <ToolButton active={tool === 'arrow'} onClick={() => setTool('arrow')} icon={<ArrowRight size={20} />} label="矢印" />
                  <ToolButton active={tool === 'rect'} onClick={() => setTool('rect')} icon={<Square size={20} />} label="赤枠" />
                  <ToolButton active={tool === 'image'} onClick={() => setTool('image')} icon={<ImageIcon size={20} />} label="画像" />
                  
                  <div className="w-10 h-px bg-slate-600 my-1"></div>
                  
                  <div className="flex flex-col gap-2 mt-2">
                      {['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#000000', '#ffffff'].map(c => (
                          <button
                              key={c}
                              onClick={() => applyColor(c)}
                              className={`w-6 h-6 rounded-full border-2 ${color === c ? 'border-white scale-110' : 'border-transparent'}`}
                              style={{ backgroundColor: c }}
                              title={c}
                          />
                      ))}
                  </div>
              </div>

              <div className="flex-1 bg-slate-500 overflow-auto relative flex items-center justify-center p-8" ref={containerRef}>
                   <div 
                      className="relative bg-white shadow-2xl transition-transform duration-100 ease-out origin-center"
                      style={{ 
                          width: page.originalWidth * zoom, 
                          height: page.originalHeight * zoom,
                          minWidth: page.originalWidth * zoom,
                          minHeight: page.originalHeight * zoom 
                      }}
                   >
                        <img 
                            ref={imgRef}
                            src={imageSrc} 
                            alt="Page" 
                            className="absolute inset-0 w-full h-full object-contain pointer-events-none select-none"
                            draggable={false}
                        />

                        <div 
                            className="absolute inset-0 z-10"
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                            style={{ cursor: tool === 'select' ? 'default' : 'crosshair' }}
                        >
                            {annotations.map(ann => renderAnnotation(ann))}
                            {currentAnnotation && renderAnnotation(currentAnnotation, true)}
                        </div>
                   </div>
              </div>

            </div>
          </div>
        );
      };

      const ToolButton = ({ active, onClick, icon, label }) => (
          <button 
              onClick={onClick}
              className={`p-3 rounded-lg transition-all flex flex-col items-center gap-1 w-full ${active ? 'bg-brand-500 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700 hover:text-white'}`}
              title={label}
          >
              {icon}
              <span className="text-[10px] whitespace-nowrap">{label}</span>
          </button>
      );

      function App() {
        const [pages, setPages] = useState([]);
        const [sources, setSources] = useState(new Map());
        const [selectedPageIds, setSelectedPageIds] = useState(new Set());
        const [isProcessing, setIsProcessing] = useState(false);
        const [isDraggingFile, setIsDraggingFile] = useState(false);
        const [editorPage, setEditorPage] = useState(null);
        const [draggedPageIndex, setDraggedPageIndex] = useState(null);

        const fileInputRef = useRef(null);

        const processFiles = useCallback(async (files, isPaste = false) => {
          if (files.length === 0) return;
          setIsProcessing(true);
          try {
              const newSources = new Map(sources);
              const newPages = [...pages];
              let lastAddedPage = null;
              let lastAddedSource = null;

              for (const file of files) {
                   try {
                      const { source, pages: extractedPages } = await loadPDF(file);
                      newSources.set(source.id, source);
                      extractedPages.forEach(p => newPages.push(p));
                      
                      if (extractedPages.length > 0) {
                          lastAddedPage = extractedPages[0];
                          lastAddedSource = source;
                      }
                   } catch (e) {
                       console.error(`Failed to load ${file.name}`, e);
                   }
              }

              setSources(newSources);
              setPages(newPages);
              
              if (isPaste && lastAddedPage && lastAddedSource) {
                   const url = await renderHighResPage(lastAddedPage, lastAddedSource);
                   setEditorPage({ page: lastAddedPage, highResUrl: url });
              }

          } catch (error) {
              console.error("Error processing files", error);
              alert("ファイルの処理中にエラーが発生しました。");
          } finally {
              setIsProcessing(false);
          }
        }, [pages, sources]);

        const handleFileUpload = (e) => {
          if (e.target.files && e.target.files.length > 0) {
              processFiles(Array.from(e.target.files));
              e.target.value = '';
          }
        };

        useEffect(() => {
            const handlePaste = (e) => {
                if (e.clipboardData && e.clipboardData.files.length > 0) {
                     e.preventDefault();
                     processFiles(Array.from(e.clipboardData.files), true);
                }
            };
            window.addEventListener('paste', handlePaste);
            return () => window.removeEventListener('paste', handlePaste);
        }, [processFiles]);

        const handleDragOverFile = (e) => {
            e.preventDefault();
            if (e.dataTransfer.types.includes('Files')) {
               setIsDraggingFile(true);
            }
        };

        const handleDragLeaveFile = (e) => {
            e.preventDefault();
            setIsDraggingFile(false);
        };

        const handleDropFile = (e) => {
            e.preventDefault();
            setIsDraggingFile(false);
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                processFiles(Array.from(e.dataTransfer.files));
            }
        };

        const handlePageDragStart = (e, index) => {
            e.stopPropagation(); 
            e.dataTransfer.effectAllowed = "move";
            setDraggedPageIndex(index);
        };

        const handlePageDragOver = (e, index) => {
            e.preventDefault();
            e.stopPropagation(); 
            e.dataTransfer.dropEffect = "move";
        };

        const handlePageDrop = (e, dropIndex) => {
            e.preventDefault();
            e.stopPropagation(); 
            
            if (draggedPageIndex === null || draggedPageIndex === dropIndex) return;

            const newPages = [...pages];
            const [draggedPage] = newPages.splice(draggedPageIndex, 1);
            newPages.splice(dropIndex, 0, draggedPage);
            
            setPages(newPages);
            setDraggedPageIndex(null);
        };

        const toggleSelectPage = (id) => {
          const newSet = new Set(selectedPageIds);
          if (newSet.has(id)) {
            newSet.delete(id);
          } else {
            newSet.add(id);
          }
          setSelectedPageIds(newSet);
        };

        const deleteSelected = () => {
          if (selectedPageIds.size === 0) return;

          if (confirm(`選択した${selectedPageIds.size}ページを削除しますか？`)) {
            setPages(prevPages => {
                const newPages = prevPages.filter(p => !selectedPageIds.has(p.id));
                return newPages;
            });
            setSelectedPageIds(new Set());
          }
        };

        const rotateSelected = () => {
          setPages(pages.map(p => {
            if (selectedPageIds.has(p.id)) {
              return { ...p, rotation: (p.rotation + 90) % 360 };
            }
            return p;
          }));
        };

        const openEditor = async (page) => {
          setIsProcessing(true);
          const source = sources.get(page.sourcePdfId);
          if (source) {
              const url = await renderHighResPage(page, source);
              setEditorPage({ page, highResUrl: url });
          }
          setIsProcessing(false);
        };

        const saveAnnotations = (newAnnotations) => {
          if (editorPage) {
              setPages(pages.map(p => p.id === editorPage.page.id ? { ...p, annotations: newAnnotations } : p));
              setEditorPage(null);
          }
        };

        const exportPDF = async () => {
          if (pages.length === 0) return;
          setIsProcessing(true);
          try {
              const pdfBytes = await generateFinalPDF(pages, sources);
              download(pdfBytes, "edited_document.pdf", "application/pdf");
          } catch (e) {
              console.error(e);
              alert("保存中にエラーが発生しました。");
          } finally {
              setIsProcessing(false);
          }
        };

        const copyToClipboard = async () => {
            if (selectedPageIds.size !== 1) {
                alert("クリップボードにコピーするには、ページを1つだけ選択してください。");
                return;
            }
            const pageId = Array.from(selectedPageIds)[0];
            const page = pages.find(p => p.id === pageId);
            const source = sources.get(page?.sourcePdfId || "");
            
            if (page && source) {
                setIsProcessing(true);
                try {
                  const baseImgUrl = await renderHighResPage(page, source);
                  const canvas = document.createElement('canvas');
                  const img = new Image();
                  img.onload = async () => {
                      canvas.width = img.width;
                      canvas.height = img.height;
                      const ctx = canvas.getContext('2d');
                      if(!ctx) return;
                      
                      ctx.drawImage(img, 0, 0);
                      
                      const loadImage = (src) => new Promise((resolve) => {
                         const i = new Image();
                         i.onload = () => resolve(i);
                         i.src = src;
                      });

                      for (const ann of page.annotations) {
                          const scale = img.width / page.originalWidth;
                          const x = ann.x * scale;
                          const y = ann.y * scale;
                          const w = (ann.width || 0) * scale;
                          const h = (ann.height || 0) * scale;

                          ctx.globalAlpha = 1.0;

                          if (ann.type === 'highlight') {
                              ctx.fillStyle = ann.color;
                              ctx.globalAlpha = 0.4;
                              ctx.fillRect(x, y, w, h);
                              ctx.globalAlpha = 1.0;
                          } else if (ann.type === 'rect') {
                              ctx.strokeStyle = ann.color;
                              ctx.fillStyle = ann.color;
                              ctx.lineWidth = 4 * scale;
                              ctx.strokeRect(x, y, w, h);
                          } else if (ann.type === 'text' && ann.text) {
                              ctx.fillStyle = ann.color;
                              ctx.font = `${ann.fontWeight || 'normal'} ${Math.max(12, (ann.fontSize || 32) * scale)}px sans-serif`;
                              ctx.textBaseline = 'top';
                              ctx.fillText(ann.text, x, y);
                          } else if (ann.type === 'arrow') {
                               ctx.strokeStyle = ann.color;
                               ctx.fillStyle = ann.color;
                               ctx.lineWidth = 5 * scale;
                               const headlen = 20 * scale; 
                               const angle = Math.atan2(h, w);
                               const toX = x + w;
                               const toY = y + h;
                               
                               ctx.beginPath();
                               ctx.moveTo(x, y);
                               ctx.lineTo(toX, toY);
                               ctx.stroke();
                               
                               ctx.beginPath();
                               ctx.moveTo(toX, toY);
                               ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                               ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                               ctx.closePath();
                               ctx.fill();
                          } else if (ann.type === 'image' && ann.imageData) {
                              const annImg = await loadImage(ann.imageData);
                              ctx.drawImage(annImg, x, y, w, h);
                          }
                      }

                      canvas.toBlob(blob => {
                          if (blob) {
                              navigator.clipboard.write([
                                  new ClipboardItem({ [blob.type]: blob })
                              ]).then(() => alert("画像をクリップボードにコピーしました！"))
                                .catch(() => alert("コピーに失敗しました"));
                          }
                      });
                      setIsProcessing(false);
                  };
                  img.src = baseImgUrl;

                } catch (e) {
                    console.error(e);
                    setIsProcessing(false);
                    alert("画像の生成に失敗しました");
                }
            } else {
              setIsProcessing(false);
            }
        };

        return (
          <div 
              className="min-h-screen bg-slate-100 flex flex-col"
              onDragOver={handleDragOverFile}
              onDragLeave={handleDragLeaveFile}
              onDrop={handleDropFile}
          >
            {isDraggingFile && (
                <div className="fixed inset-0 bg-brand-500/10 border-4 border-brand-500 z-50 flex items-center justify-center pointer-events-none">
                    <div className="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
                        <Upload size={48} className="text-brand-600 mb-2" />
                        <p className="text-xl font-bold text-brand-700">ここにファイルをドロップ</p>
                    </div>
                </div>
            )}

            <header className="bg-white border-b border-slate-200 sticky top-0 z-10 shadow-sm">
              <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
                  <div className="flex items-center gap-2">
                      <div className="bg-brand-600 text-white p-2 rounded-lg">
                          <Edit3 size={24} />
                      </div>
                      <h1 className="text-xl font-bold text-slate-800 hidden sm:block">PDF Master Studio</h1>
                  </div>

                  <div className="flex items-center gap-2">
                       <input 
                          type="file" 
                          multiple 
                          accept="application/pdf,image/*" 
                          className="hidden" 
                          ref={fileInputRef} 
                          onChange={handleFileUpload}
                      />
                      <button 
                          onClick={() => fileInputRef.current?.click()}
                          className="flex items-center gap-2 px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-md font-medium transition"
                          title="PDFや画像を追加"
                      >
                          <Plus size={18} /> <span className="hidden sm:inline">追加</span>
                      </button>

                      <div className="h-6 w-px bg-slate-300 mx-2"></div>

                      <button 
                          onClick={rotateSelected}
                          disabled={selectedPageIds.size === 0}
                          className="p-2 text-slate-600 hover:text-brand-600 disabled:opacity-30 disabled:hover:text-slate-600 transition"
                          title="回転"
                      >
                          <RotateCw size={20} />
                      </button>
                      <button 
                          onClick={deleteSelected}
                          disabled={selectedPageIds.size === 0}
                          className="p-2 text-slate-600 hover:text-red-600 disabled:opacity-30 disabled:hover:text-slate-600 transition"
                          title="削除"
                      >
                          <Trash2 size={20} />
                      </button>
                      <button 
                          onClick={copyToClipboard}
                          disabled={selectedPageIds.size !== 1}
                          className="p-2 text-slate-600 hover:text-brand-600 disabled:opacity-30 disabled:hover:text-slate-600 transition"
                          title="画像をコピー"
                      >
                          <Copy size={20} />
                      </button>

                      <div className="h-6 w-px bg-slate-300 mx-2"></div>

                      <button 
                          onClick={exportPDF}
                          disabled={pages.length === 0}
                          className="flex items-center gap-2 px-6 py-2 bg-brand-600 hover:bg-brand-700 text-white rounded-md font-bold shadow-sm transition disabled:opacity-50"
                      >
                          <FileDown size={18} /> 保存 (PDF)
                      </button>
                  </div>
              </div>
            </header>

            <main className="flex-1 p-8 overflow-y-auto">
              {pages.length === 0 ? (
                  <div className="h-full flex flex-col items-center justify-center text-slate-400 mt-20">
                      <Upload size={64} className="mb-4 opacity-50" />
                      <p className="text-xl font-medium mb-2">PDFや画像をドロップ</p>
                      <p className="text-sm">またはクリップボードから画像を貼り付け (Ctrl+V)</p>
                      <button 
                          onClick={() => fileInputRef.current?.click()}
                          className="mt-6 px-6 py-3 bg-white border border-slate-300 rounded-lg shadow-sm hover:shadow-md transition text-slate-700"
                      >
                          ファイルを選択
                      </button>
                  </div>
              ) : (
                  <div className="max-w-7xl mx-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                      {pages.map((page, index) => (
                          <div 
                              key={page.id}
                              draggable
                              onDragStart={(e) => handlePageDragStart(e, index)}
                              onDragOver={(e) => handlePageDragOver(e, index)}
                              onDrop={(e) => handlePageDrop(e, index)}
                              className={`
                                  relative group rounded-xl overflow-hidden border-2 transition-all duration-200 cursor-pointer shadow-sm
                                  ${selectedPageIds.has(page.id) ? 'border-brand-500 ring-2 ring-brand-200 shadow-md' : 'border-slate-200 hover:border-brand-300'}
                                  ${draggedPageIndex === index ? 'opacity-40 border-dashed border-brand-500' : 'opacity-100'}
                              `}
                              onClick={() => toggleSelectPage(page.id)}
                          >
                              <div className="absolute top-0 left-0 right-0 bg-black/40 text-white text-xs py-1 px-2 flex justify-between items-center opacity-0 group-hover:opacity-100 transition-opacity z-10 pointer-events-none">
                                  <span>Page {page.pageIndex + 1}</span>
                                  {page.annotations.length > 0 && <span className="bg-brand-500 px-1 rounded">編集済</span>}
                              </div>

                              <div className="bg-slate-300 aspect-[3/4] relative overflow-hidden flex items-center justify-center pointer-events-none">
                                  <div style={{ width: '100%', height: '100%', position: 'relative', transform: `rotate(${page.rotation}deg)` }}>
                                      <img 
                                          src={page.thumbnailUrl} 
                                          alt={`Page ${page.pageIndex}`}
                                          className="object-contain w-full h-full"
                                          draggable={false}
                                      />
                                      
                                      <div className="absolute inset-0 w-full h-full">
                                          {page.annotations.map((ann) => {
                                              let boxX = ann.x || 0;
                                              let boxY = ann.y || 0;
                                              let boxW = ann.width || 0;
                                              let boxH = ann.height || 0;
                                              if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
                                              if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }

                                              const left = `${(boxX / page.originalWidth) * 100}%`;
                                              const top = `${(boxY / page.originalHeight) * 100}%`;
                                              const w = `${(boxW / page.originalWidth) * 100}%`;
                                              const h = `${(boxH / page.originalHeight) * 100}%`;
                                              
                                              if (ann.type === 'rect') {
                                                  return <div key={ann.id} style={{ position: 'absolute', left, top, width: w, height: h, border: `2px solid ${ann.color}` }} />
                                              } else if (ann.type === 'highlight') {
                                                  return <div key={ann.id} style={{ position: 'absolute', left, top, width: w, height: h, backgroundColor: ann.color, opacity: 0.3 }} />
                                              } else if (ann.type === 'text') {
                                                  return (
                                                      <div key={ann.id} style={{ 
                                                          position: 'absolute', left: `${(ann.x / page.originalWidth) * 100}%`, top: `${(ann.y / page.originalHeight) * 100}%`, 
                                                          color: ann.color, 
                                                          fontSize: '10px', 
                                                          fontWeight: ann.fontWeight || 'normal', 
                                                          whiteSpace: 'nowrap', 
                                                          textShadow: '0 0 2px white'
                                                      }}>
                                                          {ann.text}
                                                      </div>
                                                  )
                                              } else if (ann.type === 'arrow') {
                                                   const startX = (ann.x / page.originalWidth) * 100;
                                                   const startY = (ann.y / page.originalHeight) * 100;
                                                   const dx = (ann.width || 0) / page.originalWidth * 100;
                                                   const dy = (ann.height || 0) / page.originalHeight * 100;
                                                   const rot = Math.atan2(dy, dx) * 180 / Math.PI;
                                                   const len = Math.sqrt(dx*dx + dy*dy);
                                                   
                                                   return (
                                                       <div key={ann.id} style={{
                                                           position: 'absolute', left: `${startX}%`, top: `${startY}%`,
                                                           width: `${len}%`, height: '2px',
                                                           backgroundColor: ann.color,
                                                           transform: `rotate(${rot}deg)`,
                                                           transformOrigin: '0 50%'
                                                       }}>
                                                           <div style={{ position: 'absolute', right: 0, top: '-3px', width: 0, height: 0, borderLeft: '6px solid ' + ann.color, borderTop: '4px solid transparent', borderBottom: '4px solid transparent' }}></div>
                                                       </div>
                                                   )
                                              } else if (ann.type === 'image' && ann.imageData) {
                                                  return <img key={ann.id} src={ann.imageData} style={{ position: 'absolute', left, top, width: w, height: h, objectFit: 'contain' }} alt="ann" />
                                              }
                                              return null;
                                          })}
                                      </div>
                                  </div>
                              </div>

                              <div className="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                  <button 
                                      onClick={(e) => {
                                          e.stopPropagation();
                                          openEditor(page);
                                      }}
                                      className="bg-white text-slate-700 hover:text-brand-600 p-2 rounded-full shadow-lg border border-slate-100"
                                      title="編集・注釈"
                                  >
                                      <Edit3 size={16} />
                                  </button>
                              </div>

                              <div className={`absolute top-2 right-2 w-6 h-6 rounded-full border-2 flex items-center justify-center transition-colors ${selectedPageIds.has(page.id) ? 'bg-brand-500 border-brand-500 text-white' : 'bg-white/80 border-slate-300 text-transparent'}`}>
                                   <Check size={14} strokeWidth={3} />
                              </div>
                          </div>
                      ))}
                  </div>
              )}
            </main>

            {editorPage && (
                <AnnotationEditor 
                  page={editorPage.page}
                  imageSrc={editorPage.highResUrl}
                  onClose={() => setEditorPage(null)}
                  onSave={saveAnnotations}
                />
            )}

            {isProcessing && (
                <div className="fixed inset-0 bg-white/70 backdrop-blur-sm z-50 flex flex-col items-center justify-center">
                    <div className="w-12 h-12 border-4 border-brand-200 border-t-brand-600 rounded-full animate-spin mb-4"></div>
                    <p className="text-slate-600 font-medium animate-pulse">処理中...</p>
                </div>
            )}
          </div>
        );
      }

      // --- MOUNT ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>