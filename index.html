<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Master Studio</title>
    <meta name="description" content="高度なPDF編集ツール。結合、ページ削除、回転、注釈（テキスト、赤枠、矢印）の追加が可能。日本語UI対応。" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
              }
            },
            animation: {
              'bounce-in': 'bounceIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards',
            },
            keyframes: {
              bounceIn: {
                '0%': { transform: 'translate(-50%, 100%)', opacity: 0 },
                '100%': { transform: 'translate(-50%, 0)', opacity: 1 },
              }
            },
            cursor: {
              'crosshair': 'crosshair',
              'text': 'text',
              'move': 'move',
            }
          }
        }
      }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF Libraries -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>

    <script>
      // PDF.js worker setup
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f5f9; }
      ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
      
      .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 0.2;
        line-height: 1.0;
        pointer-events: auto;
      }
      .textLayer span {
        color: transparent;
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
      }
      ::selection {
        background: rgba(14, 165, 233, 0.3);
      }
      .preserve-3d {
        transform-style: preserve-3d;
      }
      /* Custom Cursor Classes */
      .cursor-draw-rect { cursor: crosshair; }
      .cursor-draw-text { cursor: text; }
    </style>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-100 text-slate-800">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- ICONS ---
      const createIcon = (path) => (props) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={props.size || 24} 
          height={props.size || 24} 
          viewBox="0 0 24 24" 
          fill={props.fill || "none"} 
          stroke="currentColor" 
          strokeWidth={props.strokeWidth || 2} 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={props.className}
          {...props}
        >
          {path}
        </svg>
      );

      const Icons = {
        X: createIcon(<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>),
        Square: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        FilledSquare: createIcon(<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>),
        Circle: createIcon(<circle cx="12" cy="12" r="10"></circle>),
        ArrowRight: createIcon(<><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></>),
        Type: createIcon(<><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></>),
        Move: createIcon(<><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></>),
        Check: createIcon(<polyline points="20 6 9 17 4 12"></polyline>),
        Highlighter: createIcon(<><path d="m9 11-6 6v3h9l2-2"></path><path d="m22 7-8.1 8.1"></path><path d="M16 3 2.6 16.4"></path></>),
        ImageIcon: createIcon(<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></>),
        ZoomIn: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        ZoomOut: createIcon(<><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></>),
        Bold: createIcon(<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>),
        Upload: createIcon(<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></>),
        FileDown: createIcon(<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18v-6"></path><path d="m9 15 3 3 3-3"></path></>),
        Trash2: createIcon(<><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></>),
        RotateCw: createIcon(<path d="M23 4v6h-6 M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>),
        Edit3: createIcon(<path d="M12 20h9 M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>),
        Copy: createIcon(<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></>),
        Plus: createIcon(<><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></>),
        ChevronDown: createIcon(<polyline points="6 9 12 15 18 9"></polyline>),
        ArrowUpDown: createIcon(<><path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/></>),
        ArrowLeftRight: createIcon(<><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></>), 
        RefreshCcw: createIcon(<><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></>),
        Shapes: createIcon(<><path d="M3 3h18v18H3zM12 8l4 8H8z"/></>),
        Hash: createIcon(<><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></>),
        MessageSquare: createIcon(<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>),
        FolderPlus: createIcon(<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>),
        LayoutGrid: createIcon(<><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></>),
        Layers: createIcon(<><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></>),
        Columns: createIcon(<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>),
        ChevronLeft: createIcon(<polyline points="15 18 9 12 15 6"></polyline>),
        ChevronRight: createIcon(<polyline points="9 18 15 12 9 6"></polyline>),
        ChevronsLeft: createIcon(<><polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline></>),
        ChevronsRight: createIcon(<><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></>),
        Undo: createIcon(<><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></>),
        Redo: createIcon(<><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 3.7"/></>),
        Folder: createIcon(<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>),
      };
    
      const { 
        X, Square, FilledSquare, Circle, ArrowRight, Type, Move, Check, Highlighter, 
        ImageIcon, ZoomIn, ZoomOut, Bold, 
        Upload, FileDown, Trash2, RotateCw, Edit3, Copy, Plus, 
        ChevronDown, ArrowUpDown, ArrowLeftRight, RefreshCcw, Shapes,
        Hash, MessageSquare, FolderPlus,
        LayoutGrid, Layers, Columns,
        ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight,
        Undo, Redo, Folder
      } = Icons;

      const generateId = () => {
        if (typeof crypto !== 'undefined' && crypto.randomUUID && window.isSecureContext) {
          return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      };

      // --- UTILS ---
      const getBubblePathStr = (x, y, w, h, tail, type) => {
        const tx = x + tail.x;
        const ty = y + tail.y;
        
        if (type === 'calloutCircle') {
           const cx = x + w/2;
           const cy = y + h/2;
           const rx = Math.abs(w)/2;
           const ry = Math.abs(h)/2;
           const angle = Math.atan2(ty - cy, tx - cx);
           const px = cx + Math.cos(angle) * rx;
           const py = cy + Math.sin(angle) * ry;
           const px2 = cx + Math.cos(angle + 0.2) * rx;
           const py2 = cy + Math.sin(angle + 0.2) * ry;
           const px3 = cx + Math.cos(angle - 0.2) * rx;
           const py3 = cy + Math.sin(angle - 0.2) * ry;

           let d = `M ${cx+rx} ${cy} A ${rx} ${ry} 0 1 1 ${cx-rx} ${cy} A ${rx} ${ry} 0 1 1 ${cx+rx} ${cy}`;
           d += ` M ${px2} ${py2} L ${tx} ${ty} L ${px3} ${py3}`;
           return d;
        } else {
           const r = 10;
           const cx = x + w/2; 
           const cy = y + h/2;
           const dx = tx - cx; 
           const dy = ty - cy;
           
           let sector = 'bottom';
           if (Math.abs(dx) * h > Math.abs(dy) * w) {
              sector = dx > 0 ? 'right' : 'left';
           } else {
              sector = dy > 0 ? 'bottom' : 'top';
           }

           let d = `M ${x + r} ${y} L ${x + w - r} ${y} Q ${x + w} ${y} ${x + w} ${y + r}`;
           if (sector === 'right') {
              d += ` L ${x + w} ${y + h/2 - 10} L ${tx} ${ty} L ${x + w} ${y + h/2 + 10}`;
           }
           d += ` L ${x + w} ${y + h - r} Q ${x + w} ${y + h} ${x + w - r} ${y + h}`;
           if (sector === 'bottom') {
               d += ` L ${x + w/2 + 10} ${y + h} L ${tx} ${ty} L ${x + w/2 - 10} ${y + h}`;
           }
           d += ` L ${x + r} ${y + h} Q ${x} ${y + h} ${x} ${y + h - r}`;
           if (sector === 'left') {
               d += ` L ${x} ${y + h/2 + 10} L ${tx} ${ty} L ${x} ${y + h/2 - 10}`;
           }
           d += ` L ${x} ${y + r} Q ${x} ${y} ${x + r} ${y}`;
           if (sector === 'top') {
               d += ` L ${x + w/2 - 10} ${y} L ${tx} ${ty} L ${x + w/2 + 10} ${y}`;
           }
           d += ` Z`;
           return d;
        }
      };

      const loadPDF = async (file) => {
        let arrayBuffer = await file.arrayBuffer();
        let fileName = file.name;
        const isImage = file.type.startsWith('image/') || /\.(jpg|jpeg|png|webp)$/i.test(file.name);

        if (isImage && file.type !== 'application/pdf') {
          try {
            const pdfDoc = await PDFLib.PDFDocument.create();
            let image;
            if (file.type === 'image/jpeg' || file.type === 'image/jpg' || fileName.toLowerCase().endsWith('.jpg') || fileName.toLowerCase().endsWith('.jpeg')) {
              image = await pdfDoc.embedJpg(arrayBuffer);
            } else {
              try {
                 image = await pdfDoc.embedPng(arrayBuffer);
              } catch (e) {
                 image = await pdfDoc.embedJpg(arrayBuffer);
              }
            }
            const page = pdfDoc.addPage([image.width, image.height]);
            page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
            const pdfBytes = await pdfDoc.save();
            arrayBuffer = pdfBytes.buffer;
            fileName = fileName + ".pdf"; 
          } catch (e) {
            console.error("Image to PDF conversion failed", e);
            throw new Error("Unsupported image format.");
          }
        }

        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer.slice(0) });
        const pdf = await loadingTask.promise;
        const sourceId = generateId();
        const pages = [];

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const viewport = page.getViewport({ scale: 2.0 }); 
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport: viewport }).promise;

          pages.push({
            id: generateId(),
            sourcePdfId: sourceId,
            pageIndex: i,
            rotation: 0,
            thumbnailUrl: canvas.toDataURL(),
            originalWidth: viewport.width / 2.0,
            originalHeight: viewport.height / 2.0,
            annotations: []
          });
        }
        return { source: { id: sourceId, name: fileName, data: arrayBuffer }, pages };
      };

      const generateFinalPDF = async (pages, sources) => {
        const mergedPdf = await PDFLib.PDFDocument.create();
        for (const pageData of pages) {
          const source = sources.get(pageData.sourcePdfId);
          if (!source) continue;
          const sourcePdfDoc = await PDFLib.PDFDocument.load(source.data);
          const [copiedPage] = await mergedPdf.copyPages(sourcePdfDoc, [pageData.pageIndex]);
          
          const currentRotation = copiedPage.getRotation().angle;
          copiedPage.setRotation(PDFLib.degrees(currentRotation + pageData.rotation));

          if (pageData.annotations.length > 0) {
            const width = pageData.originalWidth;
            const height = pageData.originalHeight;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            if (ctx) {
              ctx.textBaseline = 'top'; 
              for (const ann of pageData.annotations) {
                 ctx.globalAlpha = 1.0; 
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type !== 'arrow') {
                     if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); }
                     if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                 }

                 if (ann.type === 'highlight') {
                     ctx.fillStyle = ann.color;
                     ctx.globalAlpha = 0.4;
                     ctx.fillRect(boxX, boxY, boxW, boxH);
                     ctx.globalAlpha = 1.0; 
                 } else if (ann.type === 'rect') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'filledRect') {
                   ctx.fillStyle = ann.color; ctx.fillRect(boxX, boxY, boxW, boxH);
                 } else if (ann.type === 'circle') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath();
                   ctx.ellipse(boxX + boxW/2, boxY + boxH/2, Math.abs(boxW)/2, Math.abs(boxH)/2, 0, 0, 2 * Math.PI);
                   ctx.stroke();
                 } else if (ann.type === 'cross') {
                   ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.beginPath();
                   ctx.moveTo(boxX, boxY); ctx.lineTo(boxX + boxW, boxY + boxH);
                   ctx.moveTo(boxX + boxW, boxY); ctx.lineTo(boxX, boxY + boxH); ctx.stroke();
                 } else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 32;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 } else if ((ann.type === 'callout' || ann.type === 'calloutCircle') && ann.text) {
                   ctx.fillStyle = 'white'; ctx.strokeStyle = ann.color; ctx.lineWidth = 3;
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   const pathData = getBubblePathStr(boxX, boxY, boxW, boxH, tail, ann.type);
                   const p = new Path2D(pathData);
                   ctx.fill(p); ctx.stroke(p);
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   const fSize = ann.fontSize || 24;
                   const fontFamily = ann.fontFamily || 'sans-serif';
                   ctx.font = `${fontWeight} ${fSize}px ${fontFamily}`;
                   const metrics = ctx.measureText(ann.text);
                   const textX = boxX + (boxW - metrics.width)/2;
                   const textY = boxY + (boxH - fSize)/2;
                   ctx.fillText(ann.text, textX, textY);
                 } else if (ann.type === 'arrow') {
                   ctx.strokeStyle = ann.color; ctx.fillStyle = ann.color; ctx.lineWidth = 5;
                   const startX = ann.x; const startY = ann.y;
                   const endX = ann.x + ann.width; const endY = ann.y + ann.height;
                   const headLen = 20; 
                   const angle = Math.atan2(endY - startY, endX - startX);
                   ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
                   ctx.beginPath(); ctx.moveTo(endX, endY);
                   ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                   ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                   ctx.closePath(); ctx.fill();
                 } else if (ann.type === 'image' && ann.imageData) {
                     await new Promise((resolve) => {
                         const img = new Image();
                         img.onload = () => { ctx.drawImage(img, boxX, boxY, boxW, boxH); resolve(null); };
                         img.src = ann.imageData; 
                     });
                 }
              }
              const pngImageBytes = await fetch(canvas.toDataURL('image/png')).then(res => res.arrayBuffer());
              const pngImage = await mergedPdf.embedPng(pngImageBytes);
              copiedPage.drawImage(pngImage, { x: 0, y: 0, width: copiedPage.getWidth(), height: copiedPage.getHeight() });
            }
          }
          mergedPdf.addPage(copiedPage);
        }
        return await mergedPdf.save();
      };

      const renderHighResPage = async (pageData, source) => {
          const loadingTask = pdfjsLib.getDocument({ data: source.data.slice(0) });
          const pdf = await loadingTask.promise;
          const page = await pdf.getPage(pageData.pageIndex + 1);
          const viewport = page.getViewport({ scale: 3.0, rotation: pageData.rotation });
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport: viewport }).promise;
          const textContent = await page.getTextContent();
          return { dataUrl: canvas.toDataURL(), textContent, viewport };
      };

      // --- COMPONENTS ---

      const AnnotationEditor = ({ page, imageSrc, textContent, viewportInfo, onClose, onSave }) => {
        const [annotations, setAnnotations] = useState(page.annotations || []);
        const [history, setHistory] = useState([]);
        const [redoStack, setRedoStack] = useState([]);
        const [tool, setTool] = useState('select');
        const [showShapeMenu, setShowShapeMenu] = useState(false);
        const [showTextMenu, setShowTextMenu] = useState(false);
        const [color, setColor] = useState('#ef4444');
        const [fontSize, setFontSize] = useState(32);
        const [fontFamily, setFontFamily] = useState('Meiryo UI');
        const [isBold, setIsBold] = useState(false);
        const [zoom, setZoom] = useState(0.8);
        const [isDrawing, setIsDrawing] = useState(false);
        const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 }); 
        const [currentAnnotation, setCurrentAnnotation] = useState(null); 
        const [selectedIds, setSelectedIds] = useState(new Set()); 
        const [interactionMode, setInteractionMode] = useState('none');
        const [resizeHandle, setResizeHandle] = useState(null);
        const [interactionStartPos, setInteractionStartPos] = useState({ x: 0, y: 0 });
        const [initialAnnStates, setInitialAnnStates] = useState(new Map());
        const [selectionBox, setSelectionBox] = useState(null);
        const [textSelection, setTextSelection] = useState(null); 
        
        const imgRef = useRef(null);
        const containerRef = useRef(null);
        const fileInputRef = useRef(null);
        const textMenuRef = useRef(null);
        const shapeMenuRef = useRef(null);
        const initialAnnotationsStr = useRef(JSON.stringify(page.annotations || []));

        useEffect(() => {
           const handleClickOutside = (event) => {
               if (textMenuRef.current && !textMenuRef.current.contains(event.target)) setShowTextMenu(false);
               if (shapeMenuRef.current && !shapeMenuRef.current.contains(event.target)) setShowShapeMenu(false);
           };
           document.addEventListener("mousedown", handleClickOutside);
           return () => document.removeEventListener("mousedown", handleClickOutside);
        }, []);

        const saveToHistory = (newAnns) => { setHistory(prev => [...prev, annotations]); setRedoStack([]); setAnnotations(newAnns); };
        const undo = () => {
            if (history.length === 0) return;
            const previous = history[history.length - 1];
            setRedoStack(prev => [annotations, ...prev]); setAnnotations(previous); setHistory(history.slice(0, -1));
        };
        const redo = () => {
            if (redoStack.length === 0) return;
            const next = redoStack[0];
            setHistory(prev => [...prev, annotations]); setAnnotations(next); setRedoStack(redoStack.slice(1));
        };
        const deleteSelected = () => {
            if (selectedIds.size === 0) return;
            const remaining = annotations.filter(a => !selectedIds.has(a.id));
            saveToHistory(remaining); setSelectedIds(new Set());
        };

        const handleClipboardCopy = async () => {
             const canvas = document.createElement('canvas');
             canvas.width = page.originalWidth; canvas.height = page.originalHeight;
             const ctx = canvas.getContext('2d');
             const bgImg = new Image();
             bgImg.crossOrigin = "anonymous";
             bgImg.src = imageSrc;
             await new Promise(resolve => { bgImg.onload = resolve; });
             ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
             ctx.textBaseline = 'top';
             for (const ann of annotations) {
                 ctx.globalAlpha = 1.0; 
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type !== 'arrow') { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
                 if (ann.type === 'highlight') { ctx.fillStyle = ann.color; ctx.globalAlpha = 0.4; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.globalAlpha = 1.0; }
                 else if (ann.type === 'rect') { ctx.strokeStyle = ann.color; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH); }
                 else if (ann.type === 'text' && ann.text) {
                   ctx.fillStyle = ann.color;
                   const fontWeight = ann.fontWeight === 'bold' ? 'bold' : 'normal';
                   ctx.font = `${fontWeight} ${ann.fontSize || 32}px ${ann.fontFamily || 'sans-serif'}`;
                   ctx.fillText(ann.text, ann.x, ann.y); 
                 }
                 // ... (Simplified for brevity, similar to renderAnnotation)
             }
             canvas.toBlob(blob => { if (blob) { navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]).then(() => alert("画像をクリップボードにコピーしました")); } }, 'image/png');
        };

        const fitWidth = () => { if (containerRef.current) setZoom((containerRef.current.clientWidth - 64) / page.originalWidth); };
        const fitHeight = () => { if (containerRef.current) setZoom((containerRef.current.clientHeight - 64) / page.originalHeight); };
        useEffect(() => { fitHeight(); }, []);
        const handleClose = () => {
             if (JSON.stringify(annotations) !== initialAnnotationsStr.current && !confirm("変更内容が保存されていません。破棄してもよろしいですか？")) return;
             onClose();
        };

        const handleTextSelection = () => {
            if (!imgRef.current) return;
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0 || selection.isCollapsed) { setTextSelection(null); return; }
            const range = selection.getRangeAt(0); const rects = range.getClientRects();
            const containerRect = imgRef.current.getBoundingClientRect();
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            let hasOverlap = false;
            for (let i = 0; i < rects.length; i++) {
                const rect = rects[i];
                if (rect.right > containerRect.left && rect.left < containerRect.right && rect.bottom > containerRect.top && rect.top < containerRect.bottom) {
                        minX = Math.min(minX, rect.left - containerRect.left);
                        minY = Math.min(minY, rect.top - containerRect.top);
                        maxX = Math.max(maxX, rect.right - containerRect.left);
                        maxY = Math.max(maxY, rect.bottom - containerRect.left);
                        hasOverlap = true;
                }
            }
            if (hasOverlap) {
                const scaleX = page.originalWidth / containerRect.width;
                const scaleY = page.originalHeight / containerRect.height;
                setTextSelection({ x: minX * scaleX, y: minY * scaleY, width: (maxX - minX) * scaleX, height: (maxY - minY) * scaleY });
            } else setTextSelection(null);
        };
        const applyTextHighlight = () => {
            if (!textSelection) return;
            saveToHistory([...annotations, { id: generateId(), type: 'highlight', x: textSelection.x, y: textSelection.y, width: textSelection.width, height: textSelection.height, color: '#ffff00' }]);
            setTextSelection(null); window.getSelection().removeAllRanges();
        };
        useEffect(() => { document.addEventListener('selectionchange', handleTextSelection); return () => document.removeEventListener('selectionchange', handleTextSelection); }, []);
        useEffect(() => {
          if (selectedIds.size === 1) {
              const ann = annotations.find(a => a.id === Array.from(selectedIds)[0]);
              if (ann) {
                  if (['text','callout','calloutCircle'].includes(ann.type)) { setFontSize(ann.fontSize); setIsBold(ann.fontWeight === 'bold'); setFontFamily(ann.fontFamily); }
                  if (ann.type !== 'image') setColor(ann.color);
              }
          }
        }, [selectedIds]);
        useEffect(() => {
            const handleKeyDown = (e) => {
                if (selectedIds.size === 0) return;
                const step = e.shiftKey ? 50 : 10;
                let dx = 0; let dy = 0;
                if (e.key === 'ArrowUp') dy = -step; else if (e.key === 'ArrowDown') dy = step; else if (e.key === 'ArrowLeft') dx = -step; else if (e.key === 'ArrowRight') dx = step;
                else if (e.key === 'Delete' || e.key === 'Backspace') { deleteSelected(); return; }
                else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); e.shiftKey ? redo() : undo(); return; }
                else if (e.key === 'y' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); redo(); return; }
                else return;
                if (dx !== 0 || dy !== 0) { e.preventDefault(); setAnnotations(prev => prev.map(a => selectedIds.has(a.id) ? { ...a, x: a.x + dx, y: a.y + dy } : a)); }
            };
            window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedIds, history, redoStack]);

        const getPointerPos = (e) => {
          if (!containerRef.current) return { x: 0, y: 0 };
          const rect = containerRef.current.getBoundingClientRect();
          const scaleX = page.originalWidth / rect.width;
          const scaleY = page.originalHeight / rect.height;
          return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        };
        const selectTool = (t) => {
           setSelectedIds(new Set()); setTool(t);
           const defaults = { rect: '#ef4444', filledRect: '#000000', circle: '#ef4444', cross: '#ef4444', arrow: '#ef4444', text: '#000000', callout: '#000000', calloutCircle: '#000000', highlight: '#ffff00' };
           if (defaults[t]) setColor(defaults[t]);
        };
        const handleMouseDown = (e) => {
          if (e.target.closest('button') || e.target.closest('.cursor-nw-resize') || e.target.closest('.cursor-crosshair')) return; 
          e.preventDefault(); 
          const { x, y } = getPointerPos(e); 
          setDragStartPos({ x, y });
          if (tool === 'select') {
             const clickedId = [...annotations].reverse().find(ann => {
                 let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type === 'arrow') {
                     const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height);
                     const maxX = Math.max(ann.x, ann.x + ann.width); const maxY = Math.max(ann.y, ann.y + ann.height);
                     boxX = minX - 5; boxY = minY - 5; boxW = maxX - minX + 10; boxH = maxY - minY + 10;
                 } else { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
                 if (ann.type === 'text') { const approxW = (ann.text.length * ann.fontSize) || 100; const approxH = ann.fontSize || 32; return x >= boxX && x <= boxX + approxW && y >= boxY && y <= boxY + approxH; }
                 return x >= boxX && x <= boxX + boxW && y >= boxY && y <= boxY + boxH;
             })?.id;
             if (clickedId) {
                 if (e.shiftKey) { const newSet = new Set(selectedIds); if (newSet.has(clickedId)) newSet.delete(clickedId); else newSet.add(clickedId); setSelectedIds(newSet); }
                 else { if (!selectedIds.has(clickedId)) setSelectedIds(new Set([clickedId])); setInteractionMode('moving'); setInteractionStartPos({ x, y }); const stateMap = new Map(); annotations.forEach(a => stateMap.set(a.id, {...a})); setInitialAnnStates(stateMap); }
             } else { setSelectedIds(new Set()); setSelectionBox({ x, y, w: 0, h: 0 }); setInteractionMode('selecting'); }
             return;
          }
          setIsDrawing(true);
          if (['text','callout','calloutCircle'].includes(tool)) {
             const text = prompt("テキストを入力してください:", "");
             if (text && text.trim() !== "") {
               const newAnn = { id: generateId(), type: tool, x, y, width: tool !== 'text' ? 200 : undefined, height: tool !== 'text' ? 100 : undefined, text, color, fontSize, fontWeight: isBold ? 'bold' : 'normal', fontFamily: fontFamily, tailTip: tool !== 'text' ? { x: 100, y: 150 } : undefined };
               saveToHistory([...annotations, newAnn]); setSelectedIds(new Set([newAnn.id]));
             }
             setIsDrawing(false);
          } else if (tool === 'image') { fileInputRef.current?.click(); setIsDrawing(false); }
          else { setCurrentAnnotation({ type: tool, x, y, width: 0, height: 0, color }); }
        };
        const handleMouseMove = (e) => {
          const { x, y } = getPointerPos(e);
          if (interactionMode === 'moving' && selectedIds.size > 0) {
              const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
              setAnnotations(prev => prev.map(ann => selectedIds.has(ann.id) && initialAnnStates.get(ann.id) ? { ...ann, x: initialAnnStates.get(ann.id).x + dx, y: initialAnnStates.get(ann.id).y + dy } : ann));
              return;
          }
          if (interactionMode === 'resizing' && selectedIds.size === 1) {
              const id = Array.from(selectedIds)[0]; const initial = initialAnnStates.get(id); if (!initial) return;
              const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
              setAnnotations(prev => prev.map(ann => {
                  if (ann.id !== id) return ann;
                  if (['text','callout','calloutCircle'].includes(ann.type)) {
                       const scaleFactor = 1 + (dy / (initial.height || 100)); 
                       const newSize = Math.max(10, Math.floor(initial.fontSize * scaleFactor));
                       let newW = initial.width || 0; let newH = initial.height || 0;
                       if (ann.type !== 'text') { if (resizeHandle.includes('e')) newW += dx; if (resizeHandle.includes('w')) newW -= dx; if (resizeHandle.includes('s')) newH += dy; if (resizeHandle.includes('n')) newH -= dy; }
                       return { ...ann, fontSize: newSize, width: newW, height: newH };
                  }
                  let newX = initial.x; let newY = initial.y; let newW = initial.width || 0; let newH = initial.height || 0;
                  if (resizeHandle.includes('e')) newW += dx; if (resizeHandle.includes('w')) { newX += dx; newW -= dx; } if (resizeHandle.includes('s')) newH += dy; if (resizeHandle.includes('n')) { newY += dy; newH -= dy; }
                  return { ...ann, x: newX, y: newY, width: newW, height: newH };
              })); return;
          }
          if (interactionMode === 'tail' && selectedIds.size === 1) {
             const id = Array.from(selectedIds)[0]; const initial = initialAnnStates.get(id); if (!initial) return;
             const dx = x - interactionStartPos.x; const dy = y - interactionStartPos.y;
             setAnnotations(prev => prev.map(ann => ann.id !== id ? ann : { ...ann, tailTip: { x: (initial.tailTip || {x: initial.width/2, y: initial.height+50}).x + dx, y: (initial.tailTip || {x: initial.width/2, y: initial.height+50}).y + dy } }));
             return;
          }
          if (interactionMode === 'selecting') { setSelectionBox({ x: Math.min(dragStartPos.x, x), y: Math.min(dragStartPos.y, y), w: Math.abs(x - dragStartPos.x), h: Math.abs(y - dragStartPos.y) }); return; }
          if (!isDrawing || !currentAnnotation) return;
          setCurrentAnnotation(prev => ({ ...prev, width: x - dragStartPos.x, height: y - dragStartPos.y }));
        };
        const handleMouseUp = () => {
          if (['moving','resizing','tail'].includes(interactionMode)) saveToHistory(annotations);
          if (interactionMode === 'selecting' && selectionBox) {
              const { x, y, w, h } = selectionBox; const newSelection = new Set();
              annotations.forEach(ann => {
                 let boxX = ann.x; let boxY = ann.y; let boxW = ann.width || 0; let boxH = ann.height || 0;
                 if (ann.type === 'text') { boxW = 100; boxH = 32; } 
                 if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); }
                 if (x < boxX + boxW && x + w > boxX && y < boxY + boxH && y + h > boxY) newSelection.add(ann.id);
              }); setSelectedIds(newSelection); setSelectionBox(null);
          }
          setInteractionMode('none'); setResizeHandle(null); setInitialAnnStates(new Map());
          if (!isDrawing) return; setIsDrawing(false);
          if (currentAnnotation && (Math.abs(currentAnnotation.width) > 5 || Math.abs(currentAnnotation.height) > 5)) {
             const newAnn = { id: generateId(), type: currentAnnotation.type, x: dragStartPos.x, y: dragStartPos.y, width: currentAnnotation.width, height: currentAnnotation.height, color: currentAnnotation.color };
             saveToHistory([...annotations, newAnn]); setSelectedIds(new Set([newAnn.id])); 
          } setCurrentAnnotation(null);
        };
        const handleResizeStart = (e, handle, id) => { e.stopPropagation(); e.preventDefault(); setSelectedIds(new Set([id])); setInteractionMode('resizing'); setResizeHandle(handle); setInteractionStartPos(getPointerPos(e)); const stateMap = new Map(); stateMap.set(id, {...annotations.find(a => a.id === id)}); setInitialAnnStates(stateMap); };
        const handleTailDragStart = (e, id) => { e.stopPropagation(); e.preventDefault(); setSelectedIds(new Set([id])); setInteractionMode('tail'); setInteractionStartPos(getPointerPos(e)); const stateMap = new Map(); stateMap.set(id, {...annotations.find(a => a.id === id)}); setInitialAnnStates(stateMap); };
        const renderAnnotation = (ann, isPreview = false) => {
           const isSelected = !isPreview && selectedIds.has(ann.id);
           let boxX = ann.x || 0; let boxY = ann.y || 0; let boxW = ann.width || 0; let boxH = ann.height || 0;
           if (ann.type !== 'arrow') { if (boxW < 0) { boxX += boxW; boxW = Math.abs(boxW); } if (boxH < 0) { boxY += boxH; boxH = Math.abs(boxH); } }
           else { const minX = Math.min(ann.x, ann.x + ann.width); const minY = Math.min(ann.y, ann.y + ann.height); boxX = minX; boxY = minY; boxW = Math.max(ann.x, ann.x + ann.width) - minX; boxH = Math.max(ann.y, ann.y + ann.height) - minY; }
           if (ann.type === 'text') { boxW = undefined; boxH = undefined; }
           const style = { position: 'absolute', left: `${(boxX / page.originalWidth) * 100}%`, top: `${(boxY / page.originalHeight) * 100}%`, width: boxW !== undefined ? `${(boxW / page.originalWidth) * 100}%` : 'auto', height: boxH !== undefined ? `${(boxH / page.originalHeight) * 100}%` : 'auto', pointerEvents: tool === 'select' && !isPreview ? 'auto' : 'none', cursor: tool === 'select' ? 'move' : 'crosshair', zIndex: isPreview ? 20 : (isSelected ? 30 : 10), outline: isSelected ? '2px dashed #0ea5e9' : 'none', };
           const renderHandles = () => {
               if (!isSelected || !ann.id || selectedIds.size > 1) return null;
               const hStyle = "absolute w-3 h-3 bg-white border border-brand-500 rounded-full z-50 pointer-events-auto";
               return ( <> <div className={`${hStyle} -top-1.5 -left-1.5 cursor-nw-resize`} onMouseDown={(e) => handleResizeStart(e, 'nw', ann.id)} /> <div className={`${hStyle} -top-1.5 -right-1.5 cursor-ne-resize`} onMouseDown={(e) => handleResizeStart(e, 'ne', ann.id)} /> <div className={`${hStyle} -bottom-1.5 -left-1.5 cursor-sw-resize`} onMouseDown={(e) => handleResizeStart(e, 'sw', ann.id)} /> <div className={`${hStyle} -bottom-1.5 -right-1.5 cursor-se-resize`} onMouseDown={(e) => handleResizeStart(e, 'se', ann.id)} /> {(ann.type === 'callout' || ann.type === 'calloutCircle') && ann.tailTip && ( <div className="absolute w-4 h-4 bg-yellow-400 border border-black rounded-full z-50 cursor-crosshair shadow-sm pointer-events-auto" style={{ left: `${(ann.tailTip.x / boxW) * 100}%`, top: `${(ann.tailTip.y / boxH) * 100}%`, transform: 'translate(-50%, -50%)' }} onMouseDown={(e) => handleTailDragStart(e, ann.id)} /> )} </> );
           }
           const renderContent = () => {
               if (ann.type === 'arrow') {
                   const globalStartX = ann.x; const globalStartY = ann.y; const globalEndX = ann.x + ann.width; const globalEndY = ann.y + ann.height;
                   const minX = Math.min(globalStartX, globalEndX); const minY = Math.min(globalStartY, globalEndY);
                   const headLen = 20 * (1/zoom * 0.5 + 0.5); const angle = Math.atan2(globalEndY - globalStartY, globalEndX - globalStartX);
                   return ( <svg width="100%" height="100%" style={{ overflow: 'visible', pointerEvents: 'none' }}> <line x1={globalStartX - minX} y1={globalStartY - minY} x2={globalEndX - minX} y2={globalEndY - minY} stroke="transparent" strokeWidth="20" style={{ pointerEvents: 'stroke' }} /> <line x1={globalStartX - minX} y1={globalStartY - minY} x2={globalEndX - minX} y2={globalEndY - minY} stroke={ann.color} strokeWidth="5" /> <polygon points={`${globalEndX - minX},${globalEndY - minY} ${(globalEndX - minX) - headLen * Math.cos(angle - Math.PI / 6)},${(globalEndY - minY) - headLen * Math.sin(angle - Math.PI / 6)} ${(globalEndX - minX) - headLen * Math.cos(angle + Math.PI / 6)},${(globalEndY - minY) - headLen * Math.sin(angle + Math.PI / 6)}`} fill={ann.color} /> </svg> );
               }
               if (ann.type === 'callout' || ann.type === 'calloutCircle') {
                   const tail = ann.tailTip || { x: boxW/2, y: boxH + 50 };
                   return ( <div style={{ width: '100%', height: '100%', overflow: 'visible' }}> <svg width="1" height="1" style={{ overflow: 'visible', width: '100%', height: '100%' }}> <path d={getBubblePathStr(0, 0, boxW, boxH, tail, ann.type)} fill="white" stroke={ann.color} strokeWidth="2" vectorEffect="non-scaling-stroke" /> </svg> <div style={{ position:'absolute', inset:0, display:'flex', alignItems:'center', justifyContent:'center', pointerEvents:'none' }}> <span style={{ color: ann.color, fontSize: `${(ann.fontSize || 24) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily }}>{ann.text}</span> </div> </div> )
               }
               if (ann.type === 'text') return <div style={{ color: ann.color, fontSize: `${(ann.fontSize || 32) * zoom}px`, fontWeight: ann.fontWeight, fontFamily: ann.fontFamily, whiteSpace: 'nowrap', textShadow: '0 0 3px white', padding:'4px', lineHeight:1 }}>{ann.text}</div>;
               if (ann.type === 'circle') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}`, borderRadius: '50%' }} />;
               if (ann.type === 'cross') return <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"><line x1="0" y1="0" x2="100" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/><line x1="100" y1="0" x2="0" y2="100" stroke={ann.color} strokeWidth="4" vectorEffect="non-scaling-stroke"/></svg>;
               if (ann.type === 'image') return <img src={ann.imageData} className="w-full h-full object-contain" draggable={false} />;
               if (ann.type === 'highlight') return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color, opacity: 0.3 }} />;
               if (ann.type === 'rect') return <div style={{ width: '100%', height: '100%', border: `4px solid ${ann.color}` }} />;
               if (ann.type === 'filledRect') return <div style={{ width: '100%', height: '100%', backgroundColor: ann.color }} />;
               return null;
           }
           return ( <div key={ann.id || 'preview'} style={style} onMouseDown={(e) => ann.id && !isPreview && handleMouseDown(e)}> {renderContent()} {renderHandles()} </div> );
        };
        
        // Define tool cursor class
        const getCursorClass = () => {
             if (tool === 'select') return '';
             if (tool === 'text' || tool === 'callout' || tool === 'calloutCircle') return 'cursor-text';
             return 'cursor-crosshair';
        };

        return (
          <div className="fixed inset-0 z-50 bg-gray-100 flex flex-col">
            <div className="bg-white border-b px-4 py-2 flex items-center justify-between shadow-sm z-[60] relative">
              <div className="flex items-center space-x-2">
                 <button onClick={handleClose} className="p-2 hover:bg-gray-100 rounded text-gray-600"><X size={20} /></button>
                 <span className="font-bold text-gray-700">ページ {page.pageIndex + 1} の編集</span>
                 <div className="h-6 w-px bg-gray-300 mx-2"></div>
                 <button onClick={undo} disabled={history.length === 0} className={`p-2 rounded ${history.length===0 ? 'text-gray-300' : 'hover:bg-gray-100 text-gray-600'}`}><Undo size={20} /></button>
                 <button onClick={redo} disabled={redoStack.length === 0} className={`p-2 rounded ${redoStack.length===0 ? 'text-gray-300' : 'hover:bg-gray-100 text-gray-600'}`}><Redo size={20} /></button>
              </div>
              
              <div className="flex items-center space-x-2">
                 <button onClick={() => selectTool('select')} className={`p-2 rounded ${tool === 'select' ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`}><Move size={20} /></button>
                 
                 <div className="relative" ref={textMenuRef}>
                    <button onClick={() => { setShowTextMenu(!showTextMenu); setShowShapeMenu(false); }} className={`p-2 rounded flex items-center ${['text','callout','calloutCircle'].includes(tool) ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`}><Type size={20} /><ChevronDown size={14} className="ml-1"/></button>
                    {showTextMenu && (
                        <div className="absolute top-full left-0 mt-1 w-48 bg-white border rounded shadow-lg z-50 p-1">
                           <button onClick={() => { selectTool('text'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Type size={16} className="mr-2"/> テキスト</button>
                           <button onClick={() => { selectTool('callout'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><MessageSquare size={16} className="mr-2"/> 吹き出し(四角)</button>
                           <button onClick={() => { selectTool('calloutCircle'); setShowTextMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><MessageSquare size={16} className="mr-2 rounded-full"/> 吹き出し(円)</button>
                        </div>
                    )}
                 </div>

                 <button onClick={() => selectTool('highlight')} className={`p-2 rounded ${tool === 'highlight' ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`}><Highlighter size={20} /></button>
                 
                 <div className="relative" ref={shapeMenuRef}>
                    <button onClick={() => { setShowShapeMenu(!showShapeMenu); setShowTextMenu(false); }} className={`p-2 rounded flex items-center ${['rect','filledRect','circle','cross','arrow'].includes(tool) ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`}><Shapes size={20} /><ChevronDown size={14} className="ml-1"/></button>
                    {showShapeMenu && (
                        <div className="absolute top-full left-0 mt-1 w-48 bg-white border rounded shadow-lg z-50 p-1">
                           <button onClick={() => { selectTool('rect'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Square size={16} className="mr-2"/> 枠 (赤)</button>
                           <button onClick={() => { selectTool('filledRect'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><FilledSquare size={16} className="mr-2"/> ■ 塗りつぶし</button>
                           <button onClick={() => { selectTool('circle'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><Circle size={16} className="mr-2"/> 〇 円</button>
                           <button onClick={() => { selectTool('cross'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><X size={16} className="mr-2"/> × バツ</button>
                           <button onClick={() => { selectTool('arrow'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 rounded flex items-center"><ArrowRight size={16} className="mr-2"/> 矢印</button>
                        </div>
                    )}
                 </div>

                 <button onClick={() => selectTool('image')} className={`p-2 rounded ${tool === 'image' ? 'bg-brand-100 text-brand-600' : 'hover:bg-gray-100'}`}><ImageIcon size={20} /></button>
                 
                 <div className="h-6 w-px bg-gray-300 mx-2"></div>
                 <input type="color" value={color} onChange={(e) => { setColor(e.target.value); updateSelectionStyle('color', e.target.value); }} className="w-8 h-8 rounded cursor-pointer border-0 p-0" />
                 
                 <div className="flex items-center border rounded px-2 bg-gray-50">
                    <span className="text-xs mr-1 text-gray-500">Tt</span>
                    <input type="number" min="8" max="200" step="4" value={fontSize} onChange={(e) => { const v = Math.floor(Number(e.target.value)); setFontSize(v); updateSelectionStyle('fontSize', v); }} className="w-14 text-center bg-transparent outline-none text-sm" />
                 </div>
                 
                 <select value={fontFamily} onChange={(e) => { setFontFamily(e.target.value); updateSelectionStyle('fontFamily', e.target.value); }} className="text-sm border rounded px-1 py-1 w-24">
                    <option value="Meiryo UI">メイリオ</option>
                    <option value="sans-serif">ゴシック</option>
                    <option value="serif">明朝</option>
                    <option value="monospace">等幅</option>
                 </select>
                 
                 <button onClick={() => { setIsBold(!isBold); updateSelectionStyle('fontWeight', !isBold ? 'bold' : 'normal'); }} className={`p-2 rounded ${isBold ? 'bg-gray-200' : 'hover:bg-gray-100'}`}><Bold size={20} /></button>
              </div>

              <div className="flex items-center space-x-2">
                  <button onClick={handleClipboardCopy} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded text-sm flex items-center mr-2"><Copy size={16} className="mr-1"/> コピー</button>
                  <button onClick={() => onSave(annotations)} className="bg-brand-600 hover:bg-brand-700 text-white px-4 py-2 rounded flex items-center"><Check size={20} className="mr-2" /> 完了</button>
              </div>
            </div>

            <div className="flex-1 overflow-auto relative bg-gray-200" onClick={() => { if (selectedIds.size > 0 && interactionMode === 'none') setSelectedIds(new Set()); }}>
               <div className="min-h-full flex items-center justify-center p-8">
                   <div 
                      ref={containerRef}
                      className={`relative bg-white shadow-2xl transition-transform duration-200 ease-out ${getCursorClass()}`}
                      style={{ width: page.originalWidth, height: page.originalHeight, transform: `scale(${zoom})`, transformOrigin: 'center top' }}
                      onMouseDown={handleMouseDown}
                      onMouseMove={handleMouseMove}
                      onMouseUp={handleMouseUp}
                      onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); }}
                      onDrop={(e) => { e.preventDefault(); e.stopPropagation(); }} 
                   >
                       <img ref={imgRef} src={imageSrc} className="w-full h-full pointer-events-none select-none" alt="" />
                       
                       {/* Text Selection Layer - Pointer events managed to allow drawing */}
                       <div className="textLayer" style={{ pointerEvents: tool === 'select' ? 'auto' : 'none' }}>
                           {textContent?.items?.map((item, i) => (
                             <span key={i} style={{ left: `${item.transform[4]}px`, top: `${page.originalHeight - item.transform[5] - item.height}px`, fontSize: `${item.height}px`, fontFamily: item.fontName, width: `${item.width}px`, height: `${item.height}px` }}>{item.str}</span>
                           ))}
                       </div>

                       {annotations.map(ann => renderAnnotation(ann))}
                       {currentAnnotation && renderAnnotation(currentAnnotation, true)}
                       
                       {selectionBox && (
                           <div className="absolute border-2 border-brand-500 bg-brand-500/20 pointer-events-none z-50" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }} />
                       )}

                       {textSelection && (
                           <button 
                             onClick={(e) => { e.stopPropagation(); applyTextHighlight(); }}
                             className="absolute bg-yellow-400 hover:bg-yellow-500 text-black text-xs px-2 py-1 rounded shadow-lg flex items-center z-50 animate-bounce-in"
                             style={{ left: textSelection.x + textSelection.width/2, top: textSelection.y - 40, transform: 'translateX(-50%)' }}
                           >
                             <Highlighter size={12} className="mr-1"/> マーカーを引く
                           </button>
                       )}
                       
                       {!imageSrc && (
                           <div 
                              className="absolute inset-0 flex items-center justify-center bg-gray-50 bg-opacity-90 z-40 cursor-pointer hover:bg-gray-100"
                              onClick={() => fileInputRef.current?.click()}
                           >
                               <div className="text-center text-gray-400">
                                   <ImageIcon size={48} className="mx-auto mb-2 opacity-50"/>
                                   <p>画像をドロップ または クリックして追加</p>
                               </div>
                           </div>
                       )}
                   </div>
               </div>
            </div>
            
            <div className="absolute right-4 bottom-4 flex flex-col space-y-2 bg-white rounded-lg shadow-lg p-1 border z-[60]">
               <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="p-2 hover:bg-gray-100 rounded"><ZoomIn size={20}/></button>
               <span className="text-xs text-center font-mono">{Math.round(zoom * 100)}%</span>
               <button onClick={() => setZoom(z => Math.max(0.1, z - 0.1))} className="p-2 hover:bg-gray-100 rounded"><ZoomOut size={20}/></button>
               <div className="h-px bg-gray-200 my-1"></div>
               <button onClick={fitWidth} className="p-2 hover:bg-gray-100 rounded" title="横幅に合わせる"><ArrowLeftRight size={20} className="rotate-45" /></button>
               <button onClick={fitHeight} className="p-2 hover:bg-gray-100 rounded" title="縦幅に合わせる"><ArrowUpDown size={20} /></button>
            </div>

            <input type="file" ref={fileInputRef} accept="image/*" className="hidden" onChange={(e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                         const newAnn = { id: generateId(), type: 'image', x: 50, y: 50, width: 200, height: 200, imageData: ev.target.result };
                         saveToHistory([...annotations, newAnn]);
                         setSelectedIds(new Set([newAnn.id]));
                    };
                    reader.readAsDataURL(file);
                }
            }} />
          </div>
        );
      };

      const App = () => {
        const [files, setFiles] = useState([]);
        const [pages, setPages] = useState([]);
        const [sources, setSources] = useState(new Map());
        const [editingPageId, setEditingPageId] = useState(null);
        const [editingPageInfo, setEditingPageInfo] = useState(null); 
        const [isProcessing, setIsProcessing] = useState(false);
        const [selectedPageIds, setSelectedPageIds] = useState(new Set());
        const [dragTargetIndex, setDragTargetIndex] = useState(null);
        
        const [viewMode, setViewMode] = useState('grid'); // grid, stack, carousel, groups
        const [focusedPageIndex, setFocusedPageIndex] = useState(0);
        
        const [showPageNumModal, setShowPageNumModal] = useState(false);

        const fileInputRef = useRef(null);
        const carouselContainerRef = useRef(null);

        const handleFileUpload = async (event) => {
          const fileList = event.target.files;
          if (!fileList || fileList.length === 0) return;
          setIsProcessing(true);
          try {
            const newPages = [];
            const newSources = new Map(sources);

            for (const file of Array.from(fileList)) {
              const { source, pages: extractedPages } = await loadPDF(file);
              newSources.set(source.id, source);
              newPages.push(...extractedPages);
            }
            setSources(newSources);
            setPages(prev => [...prev, ...newPages]);
          } catch (error) {
            console.error(error);
            alert("ファイルの読み込みに失敗しました: " + error.message);
          } finally {
            setIsProcessing(false);
            if (fileInputRef.current) fileInputRef.current.value = '';
          }
        };

        const handleSavePDF = async () => {
          if (pages.length === 0) return;
          setIsProcessing(true);
          try {
             const pdfBytes = await generateFinalPDF(pages, sources);
             
             if (window.showSaveFilePicker) {
                 const handle = await window.showSaveFilePicker({
                     suggestedName: 'edited_document.pdf',
                     types: [{ description: 'PDF Document', accept: {'application/pdf': ['.pdf']} }]
                 });
                 const writable = await handle.createWritable();
                 await writable.write(pdfBytes);
                 await writable.close();
             } else {
                 const name = prompt("保存するファイル名を入力してください", "edited.pdf");
                 if (name) download(pdfBytes, name.endsWith('.pdf') ? name : name + '.pdf', "application/pdf");
             }
          } catch (e) {
             console.error(e);
             if (e.name !== 'AbortError') alert("保存中にエラーが発生しました");
          } finally {
             setIsProcessing(false);
          }
        };

        const handleReset = () => {
            if (pages.length > 0 && !confirm("現在の内容はすべて破棄されます。新しいプロジェクトを開始しますか？")) return;
            setPages([]); setSources(new Map()); setSelectedPageIds(new Set()); setFocusedPageIndex(0);
        };

        const handlePageDrop = (e, targetIndex) => {
            e.preventDefault(); e.stopPropagation();
            setDragTargetIndex(null);
            
            const draggedIndex = Number(e.dataTransfer.getData('pageIndex'));
            const sourceId = e.dataTransfer.getData('sourceId');
            const dragMode = e.dataTransfer.getData('dragMode');
            
            if (isNaN(draggedIndex)) return;
            
            let newPages = [...pages];

            if (dragMode === 'group' && sourceId) {
                const groupPages = newPages.filter(p => p.sourcePdfId === sourceId);
                const nonGroupPages = newPages.filter(p => p.sourcePdfId !== sourceId);
                
                const groupIndices = newPages.map((p, i) => p.sourcePdfId === sourceId ? i : -1).filter(i => i !== -1);
                const itemsBeforeTarget = groupIndices.filter(i => i < targetIndex).length;
                const adjustedTarget = Math.max(0, targetIndex - itemsBeforeTarget);

                newPages = nonGroupPages;
                newPages.splice(adjustedTarget, 0, ...groupPages);
            } else {
                if (draggedIndex === targetIndex) return;
                const [movedPage] = newPages.splice(draggedIndex, 1);
                newPages.splice(targetIndex, 0, movedPage);
            }

            setPages(newPages);
            if (newPages.some(p => p.annotations.some(a => a.isPageNumber))) {
                const hasNum = newPages[0].annotations.find(a => a.isPageNumber);
                if (hasNum) applyPageNumbers(hasNum.align);
            }
        };

        // Group View Drag Logic
        const handleGroupDrop = (e, targetSourceId) => {
            e.preventDefault(); e.stopPropagation();
            const draggedSourceId = e.dataTransfer.getData('groupSourceId');
            if (!draggedSourceId || draggedSourceId === targetSourceId) return;

            // Reorder whole groups
            // Group pages by source
            const groups = [];
            const processed = new Set();
            pages.forEach(p => {
                if (!processed.has(p.sourcePdfId)) {
                    groups.push(pages.filter(page => page.sourcePdfId === p.sourcePdfId));
                    processed.add(p.sourcePdfId);
                }
            });

            const draggedGroupIndex = groups.findIndex(g => g[0].sourcePdfId === draggedSourceId);
            const targetGroupIndex = groups.findIndex(g => g[0].sourcePdfId === targetSourceId);
            
            if (draggedGroupIndex === -1 || targetGroupIndex === -1) return;
            
            const [movedGroup] = groups.splice(draggedGroupIndex, 1);
            groups.splice(targetGroupIndex, 0, movedGroup);
            
            setPages(groups.flat());
        };

        const applyPageNumbers = (pos) => {
            const newPages = pages.map((page, index) => {
                const newAnns = page.annotations.filter(a => !a.isPageNumber);
                const text = `- ${index + 1} -`;
                let x = page.originalWidth / 2;
                let y = page.originalHeight - 30;
                
                if (pos === 'bottomRight') {
                    x = page.originalWidth - 50;
                }
                
                newAnns.push({
                    id: generateId(), type: 'text',
                    x: x - (text.length * 8), y, 
                    text: text, fontSize: 16, color: '#000000',
                    isPageNumber: true, align: pos
                });
                return { ...page, annotations: newAnns };
            });
            setPages(newPages);
            setShowPageNumModal(false);
        };
        
        const resetPageNumbers = () => {
            setPages(pages.map(p => ({ ...p, annotations: p.annotations.filter(a => !a.isPageNumber) })));
            setShowPageNumModal(false);
        };

        const openEditor = async (page) => {
            setIsProcessing(true);
            try {
                const source = sources.get(page.sourcePdfId);
                const { textContent } = await renderHighResPage(page, source);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const viewport = (await (await pdfjsLib.getDocument({data: source.data.slice(0)}).promise).getPage(page.pageIndex+1)).getViewport({scale: 3.0, rotation: page.rotation});
                canvas.width = viewport.width; canvas.height = viewport.height;
                await (await (await pdfjsLib.getDocument({data: source.data.slice(0)}).promise).getPage(page.pageIndex+1)).render({canvasContext: ctx, viewport}).promise;

                setEditingPageInfo({ page, textContent, imageSrc: canvas.toDataURL() });
                setEditingPageId(page.id);
            } catch(e) {
                console.error(e); alert("編集画面を開けませんでした");
            } finally {
                setIsProcessing(false);
            }
        };
        
        // Navigation Logic
        useEffect(() => {
            const handleKey = (e) => {
               if (editingPageId) return;
               if (viewMode === 'grid') {
                  const cols = Math.floor((window.innerWidth - 32) / 220); // approx grid col count
                  if (e.key === 'ArrowRight') setFocusedPageIndex(i => Math.min(pages.length-1, i+1));
                  if (e.key === 'ArrowLeft') setFocusedPageIndex(i => Math.max(0, i-1));
                  if (e.key === 'ArrowDown') setFocusedPageIndex(i => Math.min(pages.length-1, i+cols));
                  if (e.key === 'ArrowUp') setFocusedPageIndex(i => Math.max(0, i-cols));
                  if (e.key === 'Enter') {
                      if (pages[focusedPageIndex]) openEditor(pages[focusedPageIndex]);
                  }
               } else {
                  if (e.key === 'ArrowRight') setFocusedPageIndex(i => Math.min(pages.length-1, i+1));
                  if (e.key === 'ArrowLeft') setFocusedPageIndex(i => Math.max(0, i-1));
               }
            };
            window.addEventListener('keydown', handleKey);
            return () => window.removeEventListener('keydown', handleKey);
        }, [editingPageId, viewMode, pages]);
        
        // Auto Scroll Carousel
        useEffect(() => {
            if (viewMode === 'carousel' && carouselContainerRef.current) {
                const card = carouselContainerRef.current.children[focusedPageIndex];
                if (card) {
                    const container = carouselContainerRef.current;
                    const scrollLeft = card.offsetLeft - (container.clientWidth / 2) + (card.clientWidth / 2);
                    container.scrollTo({ left: scrollLeft, behavior: 'smooth' });
                }
            }
        }, [focusedPageIndex, viewMode]);

        // Grouping logic for ViewMode 'groups'
        const groupedPages = React.useMemo(() => {
            const groups = new Map();
            pages.forEach(p => {
                if (!groups.has(p.sourcePdfId)) groups.set(p.sourcePdfId, []);
                groups.get(p.sourcePdfId).push(p);
            });
            return Array.from(groups.entries());
        }, [pages]);

        return (
          <div className="min-h-screen bg-gray-50 text-slate-800 font-sans flex flex-col">
            <header className="bg-white border-b sticky top-0 z-40 px-6 py-3 flex items-center justify-between shadow-sm">
              <div className="flex items-center space-x-3">
                <div className="bg-brand-600 p-2 rounded text-white"><Edit3 size={24} /></div>
                <h1 className="text-xl font-bold text-gray-800 tracking-tight">PDF Master Studio</h1>
              </div>
              <div className="flex items-center space-x-4">
                <div className="bg-gray-100 p-1 rounded-lg flex text-gray-500">
                    <button onClick={() => setViewMode('grid')} className={`p-2 rounded ${viewMode==='grid'?'bg-white text-brand-600 shadow-sm':''}`} title="グリッド"><LayoutGrid size={18}/></button>
                    <button onClick={() => setViewMode('stack')} className={`p-2 rounded ${viewMode==='stack'?'bg-white text-brand-600 shadow-sm':''}`} title="スタック"><Layers size={18}/></button>
                    <button onClick={() => setViewMode('carousel')} className={`p-2 rounded ${viewMode==='carousel'?'bg-white text-brand-600 shadow-sm':''}`} title="カルーセル"><Columns size={18}/></button>
                    <button onClick={() => setViewMode('groups')} className={`p-2 rounded ${viewMode==='groups'?'bg-white text-brand-600 shadow-sm':''}`} title="ファイルグループ"><Folder size={18}/></button>
                </div>
                
                <div className="flex items-center ml-2 border-l pl-4">
                     <label className="flex items-center space-x-2 cursor-pointer select-none">
                         <input 
                            type="checkbox" 
                            checked={pages.length > 0 && selectedPageIds.size === pages.length}
                            ref={el => { if(el) el.indeterminate = selectedPageIds.size > 0 && selectedPageIds.size < pages.length; }}
                            onChange={(e) => {
                                if (e.target.checked) setSelectedPageIds(new Set(pages.map(p => p.id)));
                                else setSelectedPageIds(new Set());
                            }}
                            disabled={pages.length === 0}
                            className="w-5 h-5 text-brand-600 rounded focus:ring-brand-500 border-gray-300" 
                         />
                         <span className="text-sm font-medium text-gray-600">すべて選択</span>
                     </label>
                </div>

                <button onClick={() => { 
                    if (selectedPageIds.size === 0) return;
                    if (!confirm(`${selectedPageIds.size} ページを削除しますか？`)) return;
                    const newPages = pages.filter(p => !selectedPageIds.has(p.id)); 
                    setPages(newPages); setSelectedPageIds(new Set()); 
                    if (newPages.some(p => p.annotations.some(a => a.isPageNumber))) {
                         const hasNum = newPages[0].annotations.find(a => a.isPageNumber);
                         if (hasNum) applyPageNumbers(hasNum.align);
                    }
                }} className={`p-2 text-red-500 hover:bg-red-50 rounded disabled:opacity-50`} disabled={selectedPageIds.size===0} title="削除"><Trash2 size={20}/></button>

                <div className="h-6 w-px bg-gray-300"></div>
                
                <button onClick={handleReset} className="text-gray-500 hover:text-red-600 p-2" title="リセット"><RefreshCcw size={20}/></button>
                
                <button onClick={() => fileInputRef.current?.click()} className="flex items-center px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg transition-colors font-medium">
                  <FolderPlus size={20} className="mr-2"/> ファイル追加
                </button>
                <input type="file" multiple accept=".pdf,image/*" ref={fileInputRef} onChange={handleFileUpload} className="hidden" />
                
                <button onClick={() => setShowPageNumModal(true)} className="flex items-center px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg transition-colors font-medium">
                  <Hash size={20} className="mr-2"/> ページ番号
                </button>
                
                <button onClick={handleSavePDF} disabled={pages.length === 0} className="flex items-center px-5 py-2 bg-brand-600 hover:bg-brand-700 text-white rounded-lg shadow-md transition-all font-bold disabled:opacity-50 disabled:cursor-not-allowed">
                  <FileDown size={20} className="mr-2"/> PDF保存
                </button>
              </div>
            </header>

            <main className="flex-1 p-6 relative" 
                  onDragOver={(e) => { 
                      if (e.dataTransfer.types.includes('Files')) {
                          e.preventDefault(); 
                          e.currentTarget.classList.add('bg-blue-50'); 
                      }
                  }}
                  onDragLeave={(e) => e.currentTarget.classList.remove('bg-blue-50')}
                  onDrop={(e) => { 
                      e.preventDefault(); e.currentTarget.classList.remove('bg-blue-50');
                      if (e.dataTransfer.files?.length > 0) {
                          fileInputRef.current.files = e.dataTransfer.files;
                          handleFileUpload({ target: { files: e.dataTransfer.files } });
                      }
                  }}
            >
              {pages.length === 0 ? (
                <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400 pointer-events-none">
                  <Upload size={64} className="mb-4 text-gray-300" />
                  <p className="text-xl font-medium text-gray-500">PDF または 画像ファイルをドロップ</p>
                  <p className="text-sm mt-2 text-gray-400">または上の「ファイル追加」ボタンから</p>
                </div>
              ) : (
                <>
                {viewMode === 'grid' && (
                    <div className="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-6 pb-20">
                      {pages.map((page, index) => {
                        const isRotated = page.rotation % 180 !== 0;
                        // For display, swap the aspect ratio if rotated 90/270
                        const displayAR = isRotated ? (page.originalHeight / page.originalWidth) : (page.originalWidth / page.originalHeight);
                        return (
                        <div 
                          key={page.id} 
                          draggable 
                          onDragStart={(e) => {
                              e.dataTransfer.setData('pageIndex', index);
                              e.dataTransfer.setData('sourceId', page.sourcePdfId);
                              if (e.shiftKey) e.dataTransfer.setData('dragMode', 'group');
                          }}
                          onDragOver={(e) => { e.preventDefault(); setDragTargetIndex(index); }}
                          onDrop={(e) => handlePageDrop(e, index)}
                          className={`relative group bg-white rounded-lg shadow-sm border-2 transition-all cursor-pointer ${focusedPageIndex === index ? 'ring-2 ring-brand-500 ring-offset-2' : ''} ${selectedPageIds.has(page.id) ? 'border-brand-500 bg-brand-50' : 'border-transparent hover:border-gray-300'}`}
                          onClick={() => setFocusedPageIndex(index)}
                          onDoubleClick={() => openEditor(page)}
                        >
                          <div className="bg-gray-100 rounded-t-lg overflow-hidden relative w-full flex items-center justify-center" style={{ aspectRatio: displayAR, minHeight: '150px' }}>
                             <div className="relative w-full h-full flex items-center justify-center">
                                 {/* Image Container: Absolute Centering */}
                                 <img 
                                    src={page.thumbnailUrl} 
                                    className="absolute"
                                    style={{ 
                                        transform: `rotate(${page.rotation}deg)`,
                                        // If rotated, the image "width" (which is visually vertical) should match container height
                                        width: isRotated ? (page.originalHeight / page.originalWidth * 100) + '%' : '100%',
                                        height: isRotated ? (page.originalWidth / page.originalHeight * 100) + '%' : '100%',
                                        maxWidth: 'none', maxHeight: 'none',
                                        objectFit: 'contain'
                                    }} 
                                    alt="" 
                                 />
                                 
                                 {/* Overlay Annotations */}
                                 <div className="absolute inset-0 pointer-events-none overflow-hidden flex items-center justify-center">
                                     <div style={{ 
                                         position: 'relative', 
                                         width: isRotated ? (page.originalHeight / page.originalWidth * 100) + '%' : '100%',
                                         height: isRotated ? (page.originalWidth / page.originalHeight * 100) + '%' : '100%',
                                         transform: `rotate(${page.rotation}deg)` 
                                     }}>
                                         {page.annotations.map(ann => {
                                             let style = { position:'absolute', left: `${(ann.x/page.originalWidth)*100}%`, top: `${(ann.y/page.originalHeight)*100}%` };
                                             if (ann.type === 'highlight') return <div key={ann.id} style={{...style, width: `${(ann.width/page.originalWidth)*100}%`, height: `${(ann.height/page.originalHeight)*100}%`, backgroundColor: ann.color, opacity:0.4}} />;
                                             if (ann.type === 'rect') return <div key={ann.id} style={{...style, width: `${(ann.width/page.originalWidth)*100}%`, height: `${(ann.height/page.originalHeight)*100}%`, border: `2px solid ${ann.color}`}} />;
                                             return null;
                                         })}
                                     </div>
                                 </div>
                             </div>
                          </div>
                          
                          <div className="p-3 flex items-center justify-between border-t bg-white rounded-b-lg">
                            <span className="text-sm font-medium text-gray-500">{index + 1}</span>
                            <div className="flex space-x-1">
                               <button onClick={(e) => { 
                                   e.stopPropagation(); 
                                   const ids = new Set(selectedPageIds); 
                                   pages.forEach(p => { if (p.sourcePdfId === page.sourcePdfId) ids.add(p.id); }); 
                                   setSelectedPageIds(ids); 
                               }} className="p-1.5 hover:bg-gray-100 rounded text-gray-500" title="このファイルのページをすべて選択"><Folder size={14}/></button>
                               <button onClick={(e) => { e.stopPropagation(); setPages(ps => ps.map(p => p.id === page.id ? { ...p, rotation: (p.rotation + 90) % 360 } : p)); }} className="p-1.5 hover:bg-gray-100 rounded text-gray-500" title="回転"><RotateCw size={14}/></button>
                               <button onClick={(e) => { e.stopPropagation(); openEditor(page); }} className="px-3 py-1 bg-brand-600 hover:bg-brand-700 text-white text-xs rounded font-bold">編集</button>
                            </div>
                          </div>
                          
                          <div className="absolute top-2 left-2 z-10" onClick={(e) => e.stopPropagation()}>
                             <input type="checkbox" checked={selectedPageIds.has(page.id)} onChange={(e) => { const newSet = new Set(selectedPageIds); if (e.target.checked) newSet.add(page.id); else newSet.delete(page.id); setSelectedPageIds(newSet); }} className="w-5 h-5 rounded border-gray-300 text-brand-600 focus:ring-brand-500" />
                          </div>

                          {dragTargetIndex === index && <div className="absolute -left-3 top-0 bottom-0 w-1 bg-brand-500 shadow-[0_0_8px_rgba(14,165,233,0.8)] z-20"></div>}
                        </div>
                      )})}
                    </div>
                )}
                
                {viewMode === 'groups' && (
                    <div className="grid grid-cols-[repeat(auto-fill,minmax(250px,1fr))] gap-8 pb-20">
                        {groupedPages.map(([sourceId, groupPages], gIndex) => {
                            const source = sources.get(sourceId);
                            const firstPage = groupPages[0];
                            return (
                                <div 
                                   key={sourceId}
                                   draggable
                                   onDragStart={(e) => e.dataTransfer.setData('groupSourceId', sourceId)}
                                   onDragOver={(e) => e.preventDefault()}
                                   onDrop={(e) => handleGroupDrop(e, sourceId)}
                                   className="bg-gray-100 p-4 rounded-xl shadow-inner cursor-move hover:bg-gray-200 transition-colors"
                                >
                                    <div className="flex items-center mb-2 space-x-2 text-gray-600">
                                        <Folder size={20} />
                                        <span className="font-bold text-sm truncate">{source?.name || 'Unknown File'}</span>
                                        <span className="text-xs bg-gray-200 px-2 py-0.5 rounded-full">{groupPages.length}p</span>
                                    </div>
                                    
                                    {/* Dense Stack Representation */}
                                    <div className="relative w-full h-64 flex justify-center items-center">
                                        <div className="relative w-40 h-56">
                                            {groupPages.slice(0, 5).map((page, i) => (
                                                <div 
                                                   key={page.id}
                                                   className="absolute top-0 left-0 w-full h-full bg-white border border-gray-300 shadow-md rounded overflow-hidden"
                                                   style={{ 
                                                       transform: `translate(${i * 4}px, ${i * 4}px)`,
                                                       zIndex: 10 - i 
                                                   }}
                                                >
                                                    <img 
                                                       src={page.thumbnailUrl} 
                                                       className="w-full h-full object-contain" 
                                                       style={{ transform: `rotate(${page.rotation}deg)` }}
                                                    />
                                                </div>
                                            ))}
                                            {groupPages.length > 5 && (
                                                <div className="absolute top-0 left-0 w-full h-full flex items-center justify-center z-20" style={{ transform: `translate(24px, 24px)` }}>
                                                    <span className="bg-black/50 text-white px-2 py-1 rounded text-xs">+{groupPages.length - 5}</span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}

                {viewMode === 'stack' && (
                    <div className="relative w-full h-full flex items-center justify-center overflow-hidden">
                        <div className="relative w-[500px] h-[700px] preserve-3d">
                             {pages.map((page, index) => {
                                 const offset = index - focusedPageIndex;
                                 if (Math.abs(offset) > 5) return null; 
                                 const zIndex = 50 - Math.abs(offset);
                                 const scale = 1 - Math.abs(offset) * 0.02; 
                                 const translateY = offset * 5; 
                                 const opacity = 1 - Math.abs(offset) * 0.1;
                                 
                                 return (
                                     <div 
                                        key={page.id}
                                        className="absolute top-1/2 left-1/2 w-full bg-white shadow-2xl rounded-lg border overflow-hidden transition-all duration-300 ease-out"
                                        style={{ 
                                            zIndex, 
                                            opacity,
                                            transform: `translate(-50%, -50%) translate(${offset * 20}px, ${-offset * 2}px) scale(${scale})`, 
                                            aspectRatio: `${page.originalWidth}/${page.originalHeight}`,
                                            height: 'auto',
                                            maxHeight: '80vh'
                                        }}
                                        onClick={() => setFocusedPageIndex(index)}
                                     >
                                        <img src={page.thumbnailUrl} className="w-full h-full object-contain" style={{ transform: `rotate(${page.rotation}deg)` }} />
                                        {index === focusedPageIndex && (
                                            <div className="absolute bottom-4 left-0 right-0 text-center">
                                                <button onClick={(e) => { e.stopPropagation(); openEditor(page); }} className="px-6 py-2 bg-brand-600 text-white rounded-full shadow-lg font-bold hover:scale-105 transition-transform">編集する</button>
                                            </div>
                                        )}
                                     </div>
                                 );
                             })}
                        </div>
                        <div className="absolute bottom-8 left-0 right-0 flex justify-center space-x-4">
                            <button onClick={() => setFocusedPageIndex(0)} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><ChevronsLeft/></button>
                            <button onClick={() => setFocusedPageIndex(i => Math.max(0, i-1))} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><ChevronLeft/></button>
                            <span className="px-4 py-2 bg-white rounded-full shadow font-mono">{focusedPageIndex+1} / {pages.length}</span>
                            <button onClick={() => setFocusedPageIndex(i => Math.min(pages.length-1, i+1))} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><ChevronRight/></button>
                            <button onClick={() => setFocusedPageIndex(pages.length-1)} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><ChevronsRight/></button>
                        </div>
                    </div>
                )}

                {viewMode === 'carousel' && (
                    <div className="w-full h-full flex flex-col">
                        <div ref={carouselContainerRef} className="flex-1 flex items-center overflow-x-auto space-x-8 px-[50vw] pb-10 scrollbar-hide">
                            {pages.map((page, index) => (
                                <div 
                                   key={page.id}
                                   className={`flex-shrink-0 transition-all duration-300 relative ${focusedPageIndex === index ? 'scale-100 opacity-100 z-10' : 'scale-90 opacity-60 grayscale'}`}
                                   style={{ maxHeight: '80vh', maxWidth: '80vw', height: 'auto', width: 'auto' }}
                                   onClick={() => setFocusedPageIndex(index)}
                                >
                                    <div className="bg-white rounded-lg shadow-xl border overflow-hidden h-full flex items-center justify-center" style={{ aspectRatio: `${page.originalWidth}/${page.originalHeight}` }}>
                                        <img src={page.thumbnailUrl} className="max-w-full max-h-[80vh] w-auto h-auto object-contain" style={{ transform: `rotate(${page.rotation}deg)` }} />
                                    </div>
                                    {focusedPageIndex === index && (
                                        <div className="absolute -bottom-12 left-0 right-0 flex justify-center">
                                           <button onClick={() => openEditor(page)} className="px-4 py-2 bg-brand-600 text-white rounded-full shadow hover:bg-brand-700 font-bold text-sm">編集</button>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                        <div className="h-12 flex justify-center items-center space-x-4 border-t bg-white">
                            <button onClick={() => setFocusedPageIndex(i => Math.max(0, i-1))} className="p-1 hover:bg-gray-100 rounded"><ChevronLeft/></button>
                            <span className="text-sm font-medium">{focusedPageIndex+1} / {pages.length}</span>
                            <button onClick={() => setFocusedPageIndex(i => Math.min(pages.length-1, i+1))} className="p-1 hover:bg-gray-100 rounded"><ChevronRight/></button>
                        </div>
                    </div>
                )}
                </>
              )}
            </main>

            {/* Editor Modal */}
            {editingPageId && editingPageInfo && (
                <AnnotationEditor 
                    page={pages.find(p => p.id === editingPageId)}
                    imageSrc={editingPageInfo.imageSrc}
                    textContent={editingPageInfo.textContent}
                    onClose={() => { setEditingPageId(null); setEditingPageInfo(null); }}
                    onSave={(newAnns) => {
                        setPages(prev => prev.map(p => p.id === editingPageId ? { ...p, annotations: newAnns } : p));
                        setEditingPageId(null); setEditingPageInfo(null);
                    }}
                />
            )}
            
            {/* Page Number Modal */}
            {showPageNumModal && (
                <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center">
                    <div className="bg-white rounded-lg shadow-lg p-6 w-96">
                        <h3 className="text-lg font-bold mb-4">ページ番号の設定</h3>
                        <div className="space-y-3">
                            <button onClick={() => applyPageNumbers('bottomCenter')} className="w-full py-3 border rounded hover:bg-brand-50 flex items-center justify-center">
                                <div className="w-32 h-20 bg-gray-100 border relative">
                                    <span className="absolute bottom-2 left-1/2 -translate-x-1/2 text-xs">- 1 -</span>
                                </div>
                                <span className="ml-4 font-bold">フッター中央</span>
                            </button>
                            <button onClick={() => applyPageNumbers('bottomRight')} className="w-full py-3 border rounded hover:bg-brand-50 flex items-center justify-center">
                                <div className="w-32 h-20 bg-gray-100 border relative">
                                    <span className="absolute bottom-2 right-2 text-xs">- 1 -</span>
                                </div>
                                <span className="ml-4 font-bold">右下</span>
                            </button>
                        </div>
                        <div className="mt-6 flex justify-between">
                            <button onClick={resetPageNumbers} className="text-red-500 text-sm hover:underline">番号を削除</button>
                            <button onClick={() => setShowPageNumModal(false)} className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">キャンセル</button>
                        </div>
                    </div>
                </div>
            )}
            
            {isProcessing && (
                <div className="fixed inset-0 z-[100] bg-white/80 flex flex-col items-center justify-center">
                    <div className="animate-spin rounded-full h-12 w-12 border-4 border-brand-200 border-t-brand-600 mb-4"></div>
                    <p className="text-lg font-bold text-brand-700">処理中...</p>
                </div>
            )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>